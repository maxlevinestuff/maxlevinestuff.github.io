<!DOCTYPE HTML>
<html>

<!-- Borksy 3.6 -->
<!-- Bitsy 5.5 -->
<!-- TEST -->

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>The Burning Locks</title>

<script type="bitsyGameData" id="exportedGameData">


# BITSY VERSION 5.5

! ROOM_FORMAT 1

PAL 0
NAME main
255,253,232
224,208,159
209,184,136
255,254,232

PAL 1
NAME dark
255,253,232
255,253,232
255,253,232
0,0,0

PAL 2
NAME blood
209,184,136
224,208,159
255,253,232
209,185,136

PAL 3
NAME ambulance
255,253,232
209,184,136
224,208,159
0,0,0

ROOM 0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
kv,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kw
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
a,a,b,a,b,a,a,m,a,b,a,a,a,a,a,a
a,0,0,0,m,0,0,0,0,0,a,0,0,0,0,a
b,0,0,0,a,0,0,0,0,0,b,0,0,0,j,a
a,0,0,0,a,0,0,0,0,0,a,0,0,0,0,b
a,0,0,0,b,0,0,0,0,0,0,0,0,0,j,a
m,0,0,0,b,j,0,0,0,0,0,0,0,0,j,b
a,0,0,0,a,l8,l9,0,0,0,0,0,j,0,j,a
b,b,a,a,a,l6,l7,j,0,0,0,j,0,j,0,a
c,c,c,c,a,b,a,a,n,n,n,n,n,b,a,a
c,c,c,c,c,c,c,o,0,0,0,0,0,p,c,c
c,c,c,c,c,c,o,l,l,k,0,0,0,k,p,c
ky,c,c,c,c,o,l,k,l,0,0,k,l,l,k,p
NAME apartment 1
ITM 2 11,5
ITM d 5,9
ITM d 7,11
ITM d 11,11
ITM d 12,10
ITM d 13,11
ITM d 14,10
ITM d 14,9
ITM d 14,8
ITM d 14,6
EXT 7,4 2 7,12
PAL 0

ROOM 1
0,0,0,0,e,0,0,0,0,0,0,0,0,0,0,0
e,0,0,0,f,0,0,0,0,e,e,f,0,0,0,0
0,3n,d,d,h,d,d,3o,0,3n,d,h,d,lc,3o,0
3n,d,lc,3g,d,d,d,d,0,d,d,d,la,g,d,3o
d,d,g,g,la,4k,d,d,0,d,d,g,g,g,3g,d
d,g,la,4k,4k,g,g,d,0,d,la,lb,4k,lb,g,d
d,g,g,lb,4k,g,la,d,3p,d,g,4k,lb,4k,la,d
lc,la,4k,4k,0,4k,g,d,d,d,la,4k,0,m,g,d
lc,g,4k,lb,0,lb,g,d,m,d,g,lb,4k,4k,la,lc
d,la,lb,4k,m,0,4k,g,la,g,4k,4k,4k,la,g,d
d,g,la,4k,4k,lb,la,g,d,g,la,m,4k,g,d,d
d,d,g,g,la,g,la,d,d,d,g,la,la,d,d,0
0,d,d,3g,g,la,d,d,i,i,la,g,d,d,0,0
0,0,d,d,lc,d,d,d,i,d,d,d,d,0,0,0
0,e,0,0,0,0,0,lc,g,d,0,0,0,e,0,e
0,0,0,0,e,0,0,d,d,d,0,0,0,0,0,0
NAME brain hub
ITM 5 8,14
PAL 0

ROOM 2
kv,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kw
b,b,b,a,b,b,a,a,a,b,a,b,a,m,b,a
b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,a
b,0,0,0,0,0,0,0,0,0,0,0,0,0,0,b
a,0,0,0,0,0,0,t,u,0,0,0,0,0,0,a
a,0,0,0,0,0,0,r,s,0,0,0,0,0,0,a
a,q,0,q,q,q,q,q,q,q,q,q,0,q,q,a
b,0,0,w,w,0,0,0,0,0,w,w,0,0,0,a
a,0,0,0,0,0,0,0,0,0,0,x,0,0,0,a
a,0,0,0,0,0,0,0,0,0,0,0,0,0,0,b
b,0,0,v,v,v,v,v,v,v,v,v,v,0,0,a
a,0,0,0,0,0,0,0,0,0,0,0,0,0,0,a
b,0,0,v,v,v,0,0,0,v,v,v,v,0,0,a
a,b,b,a,b,a,b,m,a,a,b,b,a,a,b,a
ky,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kx
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME courtroom
ITM 2 14,12
EXT 13,1 3 11,15
EXT 7,13 0 7,5
PAL 0

ROOM 3
1f,1f,1f,0,0,0,1d,1c,0,0,0,0,0,0,0,0
0,1f,1f,1f,0,1d,1c,0,0,10,12,12,12,1b,0,16
0,0,0,1f,1f,1c,0,0,0,11,1a,1a,0,13,0,0
1f,0,1d,1c,1f,1f,0,0,0,11,17,17,19,13,18,17
1f,1f,1c,0,1f,1f,1f,0,0,11,0,0,0,14,0,0
1f,1f,1f,0,16,1f,1f,0,0,11,0,0,0,15,0,0
1e,0,0,0,0,0,1f,1f,0,11,3j,3j,3j,3j,3j,3j
1e,0,0,16,0,0,0,0,0,0,0,z,0,0,0,0
1e,0,0,0,0,0,z,0,0,0,z,0,0,0,0,0
1d,1c,0,0,16,0,0,0,0,0,0,0,0,0,0,z
0,1e,0,0,0,0,0,0,0,0,0,z,z,0,0,0
0,1d,y,1c,0,0,0,0,z,z,z,0,0,0,0,0
0,0,0,1e,0,0,0,0,z,0,0,0,0,16,0,0
0,16,0,1d,1c,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,1d,y,y,y,1c,0,0,0,0,1d,y,y
0,0,0,0,0,0,0,0,1d,y,1c,0,1d,1c,0,0
NAME gallows
PAL 0

ROOM 4
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,21,0,0,0,22,0,0,0,0,0,0
0,0,0,0,0,0,21,0,22,0,0,0,0,0,0,0
0,0,0,0,0,0,0,1k,0,0,0,0,0,0,0,0
0,0,1m,1g,1v,1g,1g,1v,1g,1g,1v,1g,1g,1l,0,0
0,0,1n,0,0,0,0,0,0,0,0,23,0,1l,0,0
0,0,1n,0,0,0,0,0,20,0,0,25,24,1g,1l,0
0,0,1n,1u,1t,1s,1r,1z,1x,1y,0,26,0,0,1l,0
0,0,1l,1q,1q,1q,1q,0,1w,0,0,0,0,0,1l,0
0,0,1g,1g,1j,1g,1g,1g,1g,1g,1g,1j,1g,1g,0,0
ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld
1o,1p,1o,1p,1o,1p,1o,1p,1o,1p,1o,1p,1o,1p,1o,1p
ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld,ld
NAME ambulance
PAL 3

ROOM 5
2x,2x,2x,2x,2x,2x,2x,2x,2x,2x,2x,2x,2x,2x,2x,2x
2i,2l,0,0,0,0,0,0,0,3j,0,0,0,0,0,0
2g,2h,2i,2i,2i,2i,2i,2i,2i,2l,0,0,0,0,0,0
0,2j,2g,2g,2g,2g,2g,2g,2g,2k,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,2n,0,0,0,0,0,0
2i,2i,2i,2l,0,0,0,0,2v,2n,0,2p,2q,0,0,0
2g,2g,2g,2k,0,0,0,2w,2u,0,2t,2o,2r,2s,0,0
0,0,0,2n,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,2a,2e,29,0,0,0,0,0,0,0,0,0,0
0,0,0,2d,2b,2c,0,0,0,0,0,0,0,0,2m,2g
0,0,0,27,2f,28,0,0,0,0,0,0,2a,29,0,0
0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0
0,0,0,0,0,0,0,0,2a,29,0,0,0,0,0,0
0,0,0,2a,2e,2e,2e,2e,2b,2c,0,0,0,0,0,0
0,0,0,27,2f,2f,2f,2f,2f,28,0,0,0,0,0,0
2g,2g,2g,2g,2g,2g,2g,2g,2g,2g,2g,2g,2g,2g,2g,2g
NAME cheese factory
ITM 2 0,3
ITM 2 14,10
PAL 0

ROOM 7
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME dark
PAL 1

ROOM 8
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2z,30,2z,30,2z,2z,30,30,2z,30,2z,30,2z,30,2z,2z
31,32,31,31,31,31,4j,4j,4j,31,31,32,31,31,31,31
31,31,31,32,31,31,32,32,32,32,35,31,31,32,31,31
32,32,31,31,32,31,31,31,31,31,32,31,31,31,31,31
33,34,34,33,33,33,33,33,33,33,33,33,33,33,34,33
0,34,34,0,0,0,0,0,0,0,0,0,0,0,34,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,v,v,v,v,v,v,v,v,v,v,v,v,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,v,v,v,v,v,v,v,v,v,v,v,v,0,w
0,0,x,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME hair pageant1
PAL 0

ROOM 9
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y,2y
2z,2z,2z,30,2z,30,2z,2z,30,30,2z,30,2z,30,2z,30
31,32,31,31,31,31,31,4j,31,31,31,32,31,31,31,31
31,31,31,32,31,31,32,32,32,32,35,31,31,32,31,31
32,32,31,31,32,31,31,31,31,31,32,31,31,31,31,31
33,34,34,33,33,33,33,33,33,33,33,33,33,33,34,33
0,34,34,0,0,0,0,0,0,0,0,0,0,0,34,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,v,v,v,v,v,v,v,v,v,v,v,v,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,v,v,v,v,v,v,v,v,v,v,v,v,0,w
0,0,x,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME hair pageant2
ITM 2 9,15
PAL 0

ROOM 11
kv,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kw
c,c,c,c,c,c,c,c,c,c,c,1d,c,c,c,c
c,c,c,c,c,0,c,c,0,c,0,z,z,0,c,c
c,c,c,c,z,z,0,0,z,16,0,0,c,c,c,c
c,c,c,c,z,0,0,0,z,0,0,0,k,k,c,c
c,c,c,c,c,c,c,0,c,c,c,c,0,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,b,a,a,m,b,a,b,a,a,c,c,c,c,c,c
c,b,kl,0,0,0,0,0,0,a,c,c,c,c,c,c
c,a,kk,0,0,0,0,0,0,a,c,c,c,c,c,c
c,b,0,kj,ki,0,0,0,0,b,c,c,c,c,c,c
c,a,km,0,0,0,0,0,0,a,c,c,c,c,c,c
ky,a,b,a,b,a,a,a,a,b,c,c,c,c,c,kx
NAME intensive
PAL 0

ROOM 12
1f,1f,1f,1f,k,0,0,0,0,0,0,1e,0,0,0,0
0,16,1f,1f,0,0,0,0,0,0,0,1d,y,y,y,y
0,0,0,1f,1f,0,0,0,0,0,0,z,z,0,0,0
0,k,0,0,z,z,0,0,z,16,0,0,0,0,0,0
0,0,l5,l5,z,0,0,0,z,0,0,0,k,k,0,0
l,kz,l0,l1,l2,l3,l4,0,l5,0,0,0,0,0,0,0
a,ke,kf,kg,b,kh,b,ke,kf,kf,kg,a,b,kh,kh,a
b,0,0,0,0,0,ko,w,x,0,0,0,0,0,0,m
m,0,0,0,0,0,0,0,0,0,0,a,b,a,b,a
a,0,0,0,0,0,0,0,0,0,0,a,c,c,c,c
b,b,a,a,m,b,a,b,a,a,a,b,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
ky,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kx
NAME outside won
EXT 4,10 13 4,11
PAL 0

ROOM 13
kv,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kw
c,c,c,c,c,c,c,c,c,c,c,1d,c,c,c,c
c,c,c,c,c,0,c,c,0,c,0,z,z,0,c,c
c,c,c,c,z,z,0,0,z,16,0,0,c,c,c,c
c,c,c,c,z,0,0,0,z,0,0,0,k,k,c,c
c,c,c,c,c,c,c,0,c,c,c,c,0,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,b,a,a,m,b,a,b,a,a,c,c,c,c,c,c
c,b,kl,0,0,0,0,0,0,a,c,c,c,c,c,c
c,a,kk,0,0,0,0,0,0,a,c,c,c,c,c,c
c,b,0,kq,kp,0,0,0,0,b,c,c,c,c,c,c
c,a,kr,0,0,0,0,0,0,a,c,c,c,c,c,c
ky,a,b,a,b,a,a,a,a,b,c,c,c,c,c,kx
NAME intensive won
EXT 4,10 12 4,9
PAL 0

ROOM 14
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,kv,c,c,c,c,c,c,c,c,kw,0,0,0
0,0,0,c,c,c,c,c,c,c,c,c,c,0,0,0
0,0,0,c,c,c,c,c,c,c,c,c,c,0,0,0
0,0,0,c,c,c,c,a,b,b,a,a,c,0,0,0
0,0,0,c,c,c,c,a,ks,kt,0,a,c,0,0,0
0,0,0,c,c,c,c,b,0,0,0,m,c,0,0,0
0,0,0,c,c,c,c,b,ku,0,0,b,c,0,0,0
0,0,0,c,c,c,c,a,a,b,a,b,c,0,0,0
0,0,0,c,c,c,c,c,c,c,c,c,c,0,0,0
0,0,0,ky,c,c,c,c,c,c,c,c,kx,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME wake up won
EXT 11,8 12 1,8
PAL 0

ROOM 15
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME dark2
PAL 1

ROOM 16
0,0,6j,0,5g,6k,6l,6m,0,0,0,0,6n,6o,6p,6q
0,0,0,0,6r,6s,6t,6u,0,0,0,0,6v,6w,6x,6y
0,0,6z,70,71,72,73,0,0,0,0,0,0,0,0,0
0,0,74,75,76,77,78,79,7a,7b,0,0,0,7c,0,0
0,0,0,7d,7e,7f,7g,7h,7i,7j,7k,7l,7m,7n,7o,7p
0,0,7q,7t,7u,7v,7w,7x,5u,7y,0,7z,0,80,0,81
0,0,0,82,83,84,85,86,0,0,87,88,0,89,8a,0
0,0,0,0,8b,8c,8d,0,0,0,8e,8f,8g,8h,8i,8j
0,0,0,0,8k,8l,8m,8n,0,0,0,0,8o,0,0,0
0,0,0,0,8p,8q,8r,0,0,0,0,0,0,0,0,0
0,0,0,0,8s,8t,8u,0,0,0,0,8v,8w,8x,0,0
0,0,0,0,0,8y,0,0,0,8v,8w,8z,90,5b,0,0
0,0,0,0,0,0,0,91,92,93,94,7y,0,0,0,0
0,0,0,0,0,91,95,96,94,97,0,0,0,0,0,0
0,0,0,0,98,99,9a,le,0,9c,9d,9e,9f,9g,9h,9i
0,0,0,0,7z,le,0,0,0,9j,9k,9l,9m,9n,9o,9b
NAME title screen
PAL 3

ROOM a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
kv,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kw
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
a,a,b,a,b,a,a,m,a,b,a,a,a,a,a,a
a,0,0,0,m,j,0,0,0,0,a,0,0,0,0,a
b,j,0,0,a,0,0,0,0,0,b,0,0,0,0,a
a,0,j,j,a,0,0,0,0,0,a,0,0,0,0,b
a,j,0,0,b,0,0,0,0,0,0,0,0,0,0,a
m,0,0,j,b,j,0,0,0,0,0,0,0,0,0,b
a,j,0,j,a,l8,l9,j,0,0,0,0,0,0,0,a
b,b,a,a,a,l6,l7,0,0,0,0,0,0,0,0,a
c,c,c,c,a,b,a,a,n,n,n,n,n,b,a,a
c,36,c,c,c,c,c,o,0,0,0,0,0,p,c,c
c,c,c,c,c,c,o,l,l,k,0,0,0,k,p,c
ky,c,c,c,c,o,l,k,l,0,0,k,l,l,k,p
NAME apartment 2
ITM d 7,10
ITM d 5,9
ITM d 3,10
ITM d 3,9
ITM d 1,8
ITM d 2,7
ITM d 3,7
ITM d 1,6
ITM d 1,10
ITM d 5,5
EXT 7,4 1 13,8
PAL 0

ROOM b
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
kv,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kw
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,37
a,a,b,b,b,b,a,a,a,a,b,a,a,a,a,a
b,0,0,0,0,0,0,0,0,0,0,0,j,0,j,b
m,0,0,0,0,0,0,0,0,0,0,0,0,0,0,m
a,0,0,0,0,0,0,0,0,0,0,j,0,0,j,b
a,a,b,a,b,a,a,b,a,a,a,b,a,a,b,a
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
ky,c,c,c,c,c,c,c,c,c,c,c,c,c,36,kx
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME scary hallway
ITM c 1,8
ITM b 4,8
EXT 15,8 a 1,9
EXT 0,8 c 9,14
PAL 0

ROOM c
ld,ld,c,c,c,c,c,c,c,c,c,c,c,ld,ld,ld
ld,c,3d,c,c,c,39,c,c,39,c,c,c,c,c,ld
c,c,c,c,c,3a,0,c,3a,0,3b,c,c,3d,c,c
c,c,39,c,c,3c,0,c,0,0,0,3b,c,c,39,c
c,3a,0,c,3a,0,3j,38,3j,0,0,0,3b,3b,0,c
c,3g,0,38,0,3j,31,31,31,3j,3c,0,0,0,0,c
c,0,0,0,3g,3j,31,0,31,3j,0,0,0,3g,0,c
c,3c,0,0,0,3g,31,31,31,3j,3g,0,0,0,0,c
c,0,0,0,0,0,34,34,34,0,0,3g,0,3c,3g,c
c,0,3g,3c,0,0,34,34,34,0,0,0,3g,0,0,c
c,0,0,0,0,0,0,0,0,0,0,0,0,0,0,c
c,0,0,0,0,0,0,0,0,0,0,0,0,0,0,c
c,3e,0,0,0,0,0,0,0,0,0,0,0,0,3f,c
c,c,c,c,c,c,3i,0,3h,c,c,c,c,c,c,c
ld,c,c,c,c,c,c,0,0,0,m,c,c,c,c,ld
ld,ld,ld,c,c,c,c,c,c,c,c,c,c,c,ld,ld
NAME blood room
ITM 2 2,4
EXT 10,14 b 1,8
PAL 2

ROOM d
1f,1f,1f,1f,1f,c,c,4i,c,1f,1f,1f,0,1f,1f,1f
c,1f,1f,1f,1f,c,c,0,c,1f,1f,1f,1f,1f,1f,1f
c,c,c,1f,1f,c,c,0,c,1f,1f,1f,1f,c,c,c
c,c,c,c,1f,c,c,0,c,1f,1f,1f,c,c,c,c
1f,c,c,c,c,c,c,0,c,1f,1f,c,c,c,c,1f
1f,1f,c,c,c,c,c,0,c,c,c,c,c,c,1f,1f
1f,1f,1f,c,c,c,c,0,c,c,c,c,1f,1f,1f,1f
0,1f,1f,1f,1f,c,c,0,c,c,1f,1f,1f,1f,1f,1f
0,1f,1f,1f,1f,c,c,0,c,c,1f,1f,1f,1f,1f,1f
0,1f,0,1f,1f,c,c,0,c,c,1f,1f,1f,1f,1f,0
0,1f,1f,1f,c,c,c,0,c,c,1f,1f,1f,1f,1f,1f
1f,1f,1f,1f,c,c,c,4h,c,c,1f,1f,1f,1f,1f,1f
1f,1f,1f,c,c,c,c,c,c,c,1f,1f,1f,1f,1f,1f
1f,1f,c,c,c,1f,1f,1f,1f,c,c,1f,1f,1f,1f,1f
c,c,c,c,1f,1f,1f,1f,1f,c,c,c,1f,1f,1f,1f
c,c,c,1f,1f,0,1f,1f,1f,1f,c,c,c,c,1f,1f
NAME poop1
ITM 4 7,8
EXT 7,11 e 6,0
EXT 7,0 1 8,14
PAL 0

ROOM e
y,y,y,y,y,1c,0,1d,y,y,y,y,y,y,y,y
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,l,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,42,3x,40,3y,0,0,0,0,0,0,0,0,0
0,0,0,41,3z,3z,3z,3y,0,0,0,0,0,l,0,0
0,0,3x,3z,3z,3z,3z,3z,3y,0,0,0,0,0,0,0
0,0,a,a,b,a,a,a,a,0,0,0,0,0,0,0
0,0,a,a,a,n,n,n,a,0,0,0,0,0,0,0
0,0,a,b,a,n,n,n,a,0,0,0,0,0,0,0
0,0,a,a,a,a,b,a,a,0,0,0,0,0,0,0
0,0,a,b,m,a,a,a,b,0,0,0,0,0,l,0
0,0,0,4e,4e,4e,0,0,0,0,0,0,0,0,0,0
0,0,0,4d,4d,4f,0,0,0,0,0,0,0,0,0,0
0,0,4d,4f,4d,4d,0,0,0,0,0,0,0,0,0,0
0,0,4d,4h,4f,0,0,0,0,0,0,0,0,0,0,0
NAME poop2
EXT 4,11 i 4,11
EXT 3,15 j 3,0
EXT 6,0 d 7,11
PAL 0

ROOM g
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,kv,c,c,c,c,c,c,c,c,c,c,kw,0,0
0,0,c,c,c,c,c,c,c,c,c,c,c,c,0,0
0,0,c,c,a,a,a,b,a,a,a,b,c,c,0,0
0,0,c,c,b,0,0,3t,0,3v,0,a,c,c,0,0
0,0,c,c,a,0,3q,3s,3w,3u,0,a,c,c,0,0
0,0,c,c,a,0,3r,0,0,0,0,a,c,c,0,0
0,0,c,c,b,0,0,0,0,0,0,m,c,c,0,0
0,0,c,c,a,0,0,0,0,0,0,b,c,c,0,0
0,0,c,c,a,0,0,0,0,0,0,b,c,c,0,0
0,0,c,c,a,a,b,a,a,a,a,a,c,c,0,0
0,0,c,c,c,c,c,c,c,c,c,c,c,c,0,0
0,0,ky,c,c,c,c,c,c,c,c,c,c,kx,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME wake up
EXT 11,8 l 1,8
PAL 0

ROOM h
1f,1f,1f,0,0,0,1d,1c,0,0,0,0,0,0,0,0
0,1f,1f,1f,0,1d,1c,0,0,10,12,12,12,1b,0,16
0,0,0,1f,1f,1c,0,0,0,11,1a,1a,0,13,0,0
1f,0,1d,1c,1f,1f,0,0,0,11,17,17,19,0,18,17
1f,1f,1c,0,1f,1f,1f,0,0,11,0,0,0,0,0,0
1f,1f,1f,0,16,1f,1f,0,0,3k,0,0,0,0,0,0
1e,0,0,0,0,0,1f,1f,0,11,3j,3j,3m,3l,3j,3j
1e,0,0,16,0,0,0,0,0,0,0,z,0,0,0,0
1e,0,0,0,0,0,z,0,0,0,z,0,0,0,0,0
1d,1c,0,0,16,0,0,0,0,0,0,0,0,0,0,z
0,1e,0,0,0,0,0,0,0,0,0,z,z,0,0,0
0,1d,y,1c,0,0,0,0,z,z,z,0,0,0,0,0
0,0,0,1e,0,0,0,0,z,0,0,0,0,16,0,0
0,16,0,1d,1c,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,1d,y,y,y,1c,0,0,0,0,1d,y,y
0,0,0,0,0,0,0,0,1d,y,1c,0,1d,1c,0,0
NAME gallows2
PAL 0

ROOM i
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
kv,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kw
a,a,a,a,a,a,b,b,a,a,b,b,a,a,a,a
a,0,0,0,0,0,0,44,2i,2i,2i,2i,2i,2i,2i,a
a,2x,2x,2x,0,0,0,43,2g,2g,2g,2g,2g,2g,2g,a
b,2x,2x,0,0,0,0,45,0,0,0,0,0,0,0,a
a,0,0,48,46,0,0,45,0,4g,7r,4g,7s,7r,0,b
b,0,4a,49,47,0,4c,4b,0,0,0,0,0,0,0,b
b,0,0,0,0,0,4e,4e,0,0,0,0,0,0,0,b
a,0,0,0,0,4d,4f,0,0,0,0,0,0,0,0,a
a,0,0,0,4f,4d,0,0,0,0,0,0,0,0,0,a
a,0,0,4d,4d,4d,0,0,0,0,0,0,0,0,0,a
a,a,a,a,m,b,a,b,b,a,a,a,a,a,a,a
ky,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kx
0,0,0,0,0,0,0,0,0,0,0,l,0,0,0,0
0,0,0,l,0,0,0,0,0,0,0,0,0,0,0,0
NAME poop3
ITM 3 9,6
ITM 3 10,6
ITM 3 11,6
ITM 3 12,6
ITM 3 13,6
ITM 2 3,5
EXT 4,12 e 4,12
PAL 0

ROOM j
0,0,4d,4i,4d,0,0,0,0,0,0,0,0,0,0,0
0,0,0,4d,4d,0,0,0,0,0,0,0,0,0,0,0
0,0,0,4f,4d,4f,0,0,0,0,0,0,0,0,0,0
0,0,0,0,4d,4d,4d,4f,4d,0,0,0,0,0,l,0
0,0,0,0,4f,4d,4d,0,4f,4f,4d,0,0,0,0,0
0,0,0,0,4d,4d,4d,0,0,0,4f,0,0,0,0,0
0,0,0,0,4d,4d,4d,4d,0,0,0,0,0,0,0,0
0,0,0,0,4f,4d,4f,4d,4d,0,0,0,0,l,0,0
0,0,0,4f,4d,0,4f,4d,4d,0,0,0,0,0,0,0
0,0,4f,4f,0,0,4d,4d,4d,4d,0,0,0,0,0,0
0,0,0,0,0,0,0,4d,4d,4d,4d,0,0,0,0,0
0,0,0,0,0,0,0,4f,4d,4d,4d,0,0,0,0,0
0,0,l,0,0,0,4f,4f,4d,4d,4d,0,0,0,0,0
0,0,0,0,0,4d,4d,0,4d,4d,4d,0,0,0,0,0
0,0,0,0,0,0,0,0,4f,4d,4d,0,0,0,0,0
0,0,0,0,0,0,0,0,0,4d,4h,4f,0,0,0,0
NAME poop4
ITM 6 3,0
EXT 10,15 k 8,0
PAL 0

ROOM k
0,0,0,0,0,0,0,4d,4i,4d,4d,0,0,0,0,0
0,0,0,0,0,0,0,4d,4d,0,0,0,0,0,0,0
0,0,0,0,0,0,0,4d,4d,0,0,0,0,0,0,0
0,0,0,0,0,0,4d,4d,4f,0,0,0,0,0,0,0
0,0,0,0,0,4f,4d,4d,4d,0,0,0,0,0,0,0
0,0,0,0,4f,4f,4d,4d,0,0,0,0,0,0,0,0
0,0,0,0,4f,0,4d,4d,0,0,0,0,0,0,0,0
0,0,0,0,0,0,4f,4d,4d,0,0,0,0,0,l,0
0,0,0,0,0,0,4d,4d,4d,0,0,0,0,0,0,0
0,0,0,0,0,4f,4d,4d,4d,4f,0,0,0,0,0,0
0,0,0,0,0,4d,4d,0,0,4f,4f,0,0,0,0,0
0,0,0,0,4d,4d,4d,0,0,0,0,0,0,0,0,0
0,0,0,0,4d,4d,0,0,0,0,0,0,0,0,0,0
0,0,0,4d,4d,4d,0,0,0,0,0,0,0,0,0,0
0,0,4f,4d,4d,0,0,0,0,0,0,0,0,0,0,0
0,0,4d,4h,4f,0,0,0,0,0,0,0,0,0,0,0
NAME poop5
ITM 7 3,15
EXT 8,0 j 10,15
PAL 0

ROOM l
1f,1f,1f,1f,k,0,0,0,0,0,0,1e,0,0,0,0
0,16,1f,1f,0,0,0,0,0,0,0,1d,y,y,y,y
0,0,0,1f,1f,0,0,0,0,0,0,z,z,0,0,0
0,k,0,0,z,z,0,0,z,16,0,0,0,0,0,0
0,0,0,0,z,0,0,0,z,0,0,0,k,k,0,0
l,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
a,ke,kf,kg,b,kh,b,ke,kf,kf,kg,a,b,kh,kh,a
b,0,0,0,0,0,ko,w,x,0,0,0,0,0,0,m
m,0,0,0,0,0,0,0,0,0,0,a,b,a,b,a
a,0,0,0,0,0,0,0,0,0,0,a,c,c,c,c
b,b,a,a,m,b,a,b,a,a,a,b,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c
ky,c,c,c,c,c,c,c,c,c,c,c,c,c,c,kx
NAME outside
EXT 0,8 g 10,8
END 0 15,7
PAL 0

TIL 1
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME title screen 1

TIL 2
11111111
11111111
11111001
11111111
11110011
11110011
11110001
11000001
NAME title screen 2

TIL 3
11111111
11111111
11111111
11111111
00111111
11111111
11111111
10110111
NAME title screen 3

TIL 4
11111111
11111111
11111111
11111111
11111111
11110011
11011000
10110000
NAME title screen 4

TIL 5
11111001
11111100
11000000
11000000
11000000
00000000
01000000
00100001
NAME title screen 5

TIL 6
11000001
11100000
00100010
01100010
00100011
00110011
00000011
10001111
NAME title screen 6

TIL 7
00111111
00110111
11111111
11111111
11111111
11101111
11111011
11111111
NAME title screen 7

TIL 8
11111111
11111111
11111111
11111111
11101110
11111001
11111000
11110000
NAME title screen 8

TIL 9
01100000
11100000
10000000
10000000
01100000
10000000
00000000
00000000
NAME title screen 9

TIL 10
00111111
01101101
11100111
10111101
10011001
10011001
10011001
10011001
NAME gallows1
WAL true

TIL 11
10011001
10011001
11110111
10011001
11101111
10011001
11110111
10011001
NAME gallows2
WAL true

TIL 12
11111111
10010010
11111111
00000000
00000000
00000000
00000000
00000000
NAME gallows3
WAL true

TIL 13
00101000
00010000
00101000
00111000
00010000
00101000
00110000
00011000
NAME rope1
WAL true

TIL 14
00011000
00111100
01000010
01100110
01000010
01000010
00111100
00011000
NAME rope2
WAL true

TIL 15
00011000
00011000
00111100
01011010
01011010
00011000
00111100
01100110
NAME rope3
WAL true

TIL 16
00011000
00011000
11011011
11011011
01111110
00111100
00011000
00011000
NAME cactus
WAL true

TIL 17
11111111
00100101
00100101
11111111
00000000
00000000
00000000
00000000
NAME gallows4
WAL true

TIL 18
00000001
00000010
00000100
00001101
00010110
00010100
00011000
00010000
NAME gallows5
WAL true

TIL 19
11000000
00100000
00010000
11011000
00110100
00010100
00001100
00000000
NAME gallows6
WAL true

TIL 20
00000000
00000000
11111100
01011110
11111110
01001100
00111000
00111000
NAME paramedic5

TIL 21
10000000
01000000
00100000
00010000
00001000
00000100
00000010
00000001
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME ray1

TIL 22
00000001
00000000
00000100
00001000
00000000
00000000
01000000
10000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME ray2

TIL 23
00000000
00000000
00111100
00111100
00111110
00111100
00011000
00011000
NAME driver1

TIL 24
00000000
00001000
11111100
00010100
00010100
00010100
00011100
00001000
NAME driver2

TIL 25
00111000
00111000
00111111
00111100
00111100
00111100
11111100
11111100
NAME driver3

TIL 26
11111110
11111110
00000110
00000111
00000111
00000110
00000111
00000111
NAME driver4

TIL 27
10000000
10000000
10011000
10100100
10100100
10011000
01000000
00111111
NAME cheese1
WAL true

TIL 28
00000001
00000001
00001001
00010101
00001001
00000001
00000010
11111100
NAME cheese2
WAL true

TIL 29
11111100
00000010
01100001
10010001
10010001
01100001
00000101
00000001
NAME cheese3
WAL true

TIL 30
00100010
11011101
00001000
11111111
01000000
01000000
11111111
00010000
NAME curtain3
WAL true

TIL 31
00000000
11111111
00000010
00000010
11111111
00010000
00010000
11111111
NAME stage floor1

TIL 32
00001000
11111111
01000000
01000000
11111111
00000010
00000010
11111111
NAME stage floor2

TIL 33
00000000
11101111
11101111
00000000
11101111
11101111
11101111
00000000
NAME stage floor3
WAL true

TIL 34
11111111
00000000
11111111
00000000
11111111
00000000
11111111
00000000
NAME stage steps

TIL 35
11111111
01111110
01111110
01111110
01111110
01111110
01111110
01111110
NAME pageant podium
WAL true

TIL 36
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
10111011
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME creepy eyes
WAL true

TIL 37
11111101
11011101
11011010
10101101
10101010
01110101
01111101
10111110
>
11111111
10110011
01111011
10101101
10101010
01010101
01111001
10110110
NAME inverted fire
WAL true

TIL 38
11111111
11111111
11111111
01111111
00111111
00011110
00000000
00000000
>
11111111
11111111
11111111
11111111
11111111
01100000
00000000
00000000
NAME blood1
WAL true

TIL 39
11111111
11111111
11110011
11000001
10000000
00000000
00000000
00000000
>
11111111
11111111
11100011
11000001
10100000
00000000
00000000
00000000
NAME blood2
WAL true

TIL 40
11111111
10010000
11111111
00000100
11111111
00100000
11111111
10010000
NAME roof4
WAL true

TIL 41
10001001
11111010
11111111
11111010
11111111
11100100
11111111
10010000
NAME roof5
WAL true

TIL 42
00000000
00000000
01000000
00000000
00010000
01000000
00100000
00000000
>
00000000
00000000
00100000
00000000
01000000
00000000
00010000
00000000
NAME smoke
WAL true

TIL 43
00111111
01110000
01110110
01101101
01101001
01010110
01001000
00000011
>
00111111
00111000
01110110
01101001
01101011
01010110
01001000
01000101
NAME conveyer belt6
WAL true

TIL 44
00000000
00000000
00000000
00000000
00000000
00001111
00111111
00111111
>
00000000
00000000
00000000
00000000
00000000
00000111
00011111
00111111
NAME melted 5
WAL true

TIL 45
00000000
01000000
01000000
01000000
01000000
00000000
01000000
01000000
>
01000000
00000000
01000000
01000000
01000000
00000000
01000000
00000000
NAME melted6
WAL true

TIL 46
00000000
00000000
00000000
11111111
10000101
01111001
00000001
01111001
NAME poop bucket1
WAL true

TIL 47
10000101
01111001
00000001
01100001
10010001
11111101
00000001
11111111
NAME poop bucket2
WAL true

TIL 48
00000000
00000000
00000000
00111111
01010000
01010000
01010000
01010000
NAME poop bucket3
WAL true

TIL 49
01010000
01010000
01010000
01010000
01010000
11110000
11110000
11111111
NAME poop bucket4
WAL true

TIL 50
11011100
11100110
11110110
11111111
11011111
11111111
11100111
11111111
NAME title screen 26

TIL 51
01111111
01111111
01111111
00111111
11111111
11111111
11111111
11111111
NAME title screen 27

TIL 52
11100100
11111011
11111111
11111111
11111111
11111111
11111111
11111111
NAME title screen 28

TIL 53
00011100
11111000
11111111
11111111
11111111
11111111
11111111
11111111
NAME title screen 29

TIL 54
00000011
00010011
00010011
10001101
11111111
11111111
11111111
11111111
NAME title screen 30

TIL 55
11111111
11111111
11111111
11111111
11111110
11111100
11110000
11100000
NAME title screen 31

TIL 56
11111111
11110111
11110000
11000010
10000000
10000000
00000000
00000000
NAME title screen 32

TIL 57
11111111
11111111
11111111
00111111
00000011
00000000
00000001
00000000
NAME title screen 33

TIL 58
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00001111
NAME title screen 34

TIL 59
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00011111
NAME title screen 35

TIL 60
10000000
10010010
11111110
11111110
11111111
11111111
11111111
11111111
NAME title screen 62

TIL 61
00000000
00000000
00000110
00000001
11110011
11111111
11111111
11111111
NAME title screen 63

TIL 62
00000000
00000100
00000000
11000000
11111111
11111111
11111111
11111111
NAME title screen 64

TIL 63
00000000
00000000
00000000
00000000
00000000
00000000
10000000
10000000
NAME title screen 65

TIL 64
00000011
00000011
00000011
00000011
00000011
00000011
00000011
00110011
NAME title screen 66

TIL 65
11111111
11111111
11111111
11111111
11111110
11111000
11110000
11100000
NAME title screen 67

TIL 66
10000000
00000000
00000000
00000000
00000000
00000000
00000110
00000110
NAME title screen 68

TIL 67
00010111
00001111
00001111
00001100
00000001
00000001
00001100
00001111
NAME title screen 69

TIL 68
11100000
11111111
11111111
11111111
11110011
11110011
00000011
10000011
NAME title screen 70

TIL 69
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME title screen 71

TIL 70
00000000
00000000
00000000
00000000
00011000
00011000
11111110
00011100
NAME title screen 98

TIL 71
00000001
00000001
00000011
00000011
00000011
00000000
00000000
00000000
NAME title screen 99

TIL 72
11111100
11111100
11111100
11111000
11110010
11100011
11100011
11010001
NAME title screen 100

TIL 73
00000000
00000000
00000000
00000000
00000000
00010000
10010000
10000000
NAME title screen 101

TIL 74
00000011
00000110
00001000
00001000
00000000
00000000
00000000
00000000
NAME title screen 102

TIL 75
10011110
00001111
00000111
00000011
00000001
00000000
00000000
00000000
NAME title screen 103

TIL 76
00000011
11000001
11100000
11110000
11110010
11110000
11110000
00111000
NAME title screen 104

TIL 77
10010001
00010001
01100011
01100011
01000011
00000011
00000011
10000111
NAME title screen 105

TIL 78
11000000
11100010
11100000
11100000
11100000
11100000
11100000
11000000
NAME title screen 106

TIL 79
00000000
00000000
00000000
00000000
10000000
00000000
00000000
00100000
NAME title screen 107

TIL 80
00000100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 132

TIL 81
11100000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 133

TIL 82
00000001
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 134

TIL 83
00001111
00000111
10000111
01000011
01100011
00110001
00011001
00000001
NAME title screen 135

TIL 84
11100111
11100011
11011110
11001110
11101111
11111111
11111111
11111111
NAME title screen 136

TIL 85
01011111
10011111
10011111
00111110
00111000
01111000
11100000
10000000
NAME title screen 137

TIL 86
10000000
10000000
01000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 138

TIL 87
00000000
00000000
00000000
00000000
00000001
00000001
00000001
00000001
NAME title screen 139

TIL 88
00000000
00000000
00000000
00000000
00000000
10000000
10000000
10000000
NAME title screen 140

TIL 89
00000000
00000000
00000000
00000000
00000000
00000000
01111000
11111001
NAME title screen 141

TIL 90
11111110
11111110
11101100
10110000
11000000
00000000
00000000
00000000
NAME title screen 168

TIL 91
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000011
NAME title screen 169

TIL 92
00000000
00000000
00000001
00000111
00011111
00111111
11111111
11111111
NAME title screen 170

TIL 93
00011111
01111111
11111111
11111111
11111111
11111111
11111110
11111000
NAME title screen 171

TIL 94
11111111
11111111
11111110
11111000
11100000
10000000
00000000
00000000
NAME title screen 172

TIL 95
00000000
00000000
00000000
00000011
00001111
00111111
11111111
11111111
NAME title screen 173

TIL 96
00001111
00111111
11111111
11111111
11111111
11111111
11111110
11111100
NAME title screen 174

TIL 97
11100000
10000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 175

TIL 98
00000000
00000000
00000000
00000001
00000011
00000011
00000011
00000001
NAME title screen 176

TIL 99
00001111
00111111
01111111
10111111
11111111
11011111
11101111
11111100
NAME title screen 177

TIL a
11111111
10010001
11111111
10000101
11111111
10100001
11111111
11111111
NAME brick 1
WAL true

TIL b
11111111
10010001
01110110
10001001
01110110
11111111
10001001
11111111
NAME brick 2
WAL true

TIL c
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME space
WAL true

TIL d
10011010
00100101
01001001
10010010
10100100
10010010
10001010
01010001
>
01010001
10101100
10101010
01101001
01010101
10101001
10100101
01010010
NAME brain material
WAL true

TIL e
00000000
00000000
00100000
00010000
00001000
00000000
00010000
00001000
>
00000000
00000000
00000100
10000010
01000001
00000000
00000000
00000000
NAME vein

TIL f
00000000
00000000
00111100
01011110
10011101
10000001
10000001
11111111
>
00000000
00000000
00111100
01111010
10111001
10000001
10000001
11111111
NAME eye

TIL g
00000000
00000000
00000000
00011000
00000100
00000000
01000000
00000000
>
00000000
01000000
00011100
00100010
00011010
01000100
10100000
01000000
NAME brain floor 1

TIL h
01001001
10010001
01001011
00110010
00011100
00110000
11000000
10000000
>
01001001
00100101
01001001
00110011
00011100
00010000
11100000
10000000
NAME eye stalk

TIL i
10011010
00100101
01001001
10010010
10100100
10010010
10001010
01010001
>
01010001
10101100
10101010
01101001
01010101
10101001
10100101
01010010
NAME brain material unsolid
WAL false

TIL j
00000010
00100010
00100101
01010010
01010101
10001010
10000010
01000001
>
00000000
01001100
10000100
01010010
01010101
10101010
10000110
01001001
NAME fire

TIL k
00011000
00011000
00111000
01111100
01111110
11011011
10011001
00011000
NAME tree
WAL true

TIL l
00000000
00000000
00000010
01000100
00100100
00100000
00000000
00000000
NAME grass
WAL false

TIL m
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME door
WAL false

TIL n
00000000
11111111
10000001
10000001
10000001
10000001
11111111
00000000
NAME window
WAL true

TIL o
11111111
11111110
11111100
11111000
11110000
11100000
11000000
10000000
NAME cross dark

TIL p
11111111
01111111
00111111
00011111
00001111
00000111
00000011
00000001
NAME cross dark 2

TIL q
00000000
00000000
00000000
00000000
11111111
01010101
01010101
01010101
NAME rail
WAL true

TIL r
01111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME podium1
WAL true

TIL s
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME podium2
WAL true

TIL t
11111111
01111111
01111111
01111111
01111111
01111111
01111111
01111111
NAME podium3
WAL true

TIL u
11111111
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME podium4
WAL true

TIL v
11111111
11111111
11111111
10000001
10000001
00000000
00000000
00000000
NAME seat
WAL true

TIL w
00000000
00000000
00000000
11111111
00011000
00011000
00011000
00000000
NAME table
WAL true

TIL x
00000100
00000100
00000100
00000100
00111100
00100100
00100100
00000000
NAME chair
WAL true

TIL y
00011000
00111100
11111111
11111111
00111100
00111100
00111100
00111100
NAME fence1
WAL true

TIL z
00000000
00000010
00000100
00010100
00100000
00100000
00000000
00000000
>
00000000
00001000
00000100
01000100
00100000
00100000
00000000
00000000
NAME grass

TIL 1a
00000000
00000000
00000000
11111111
10010001
10010001
11111111
10000001
NAME gallows 7
WAL true

TIL 1b
11111000
01100100
11010100
01101100
00111000
00101000
00110000
00011000
NAME gallows 8
WAL true

TIL 1c
00011000
00111100
11111100
11111100
00111100
00111100
00111100
00111100
NAME fence2
WAL true

TIL 1d
00011000
00111100
00111111
00111111
00111100
00111100
00111100
00111100
NAME fence3
WAL true

TIL 1e
00011000
00111100
00111100
00111100
00111100
00111100
00111100
00111100
NAME fence4
WAL true

TIL 1f
00001000
01000100
00100010
00010000
00001000
01000100
00100000
00010000
>
00000000
00000000
01000100
00100010
00010001
00001000
01000100
00100000
NAME light
WAL true

TIL 1g
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME ambulance wall1

TIL 1i
11111111
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME ambulance wall3

TIL 1j
11111111
01111110
11000011
11010011
11001011
11000111
01011110
00111100
>
11111111
01111110
10000011
11001011
11010011
11000011
01111110
00111100
NAME wheel

TIL 1k
00000000
01111110
01000010
01000110
01001010
01010010
01000010
11111111
>
00000000
01111110
01000010
01100010
01010010
01001010
01000010
11111111
NAME ambulance light

TIL 1l
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME ambulance wall2

TIL 1m
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME ambulance wall4

TIL 1n
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME ambulance wall5

TIL 1o
11111111
11111111
11111111
00000000
00000000
00000000
11111111
11111111
>
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME road lines1
COL 2

TIL 1p
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
>
11111111
11111111
11111111
00000000
00000000
00000000
11111111
11111111
NAME road lines2
COL 2

TIL 1q
11111111
00100010
00100010
01000100
01000100
10001000
10001000
10001000
NAME gurney

TIL 1r
00000000
00000000
00001100
01011111
11011001
11011111
11111111
11111111
NAME person on gurney1

TIL 1s
00000000
00000000
00000000
00000000
00000000
11111110
11111111
11111111
NAME person on gurney2

TIL 1t
00000000
00000000
00000000
00000000
00000000
00000000
11111111
11111111
NAME person on gurney3

TIL 1u
00000000
00000000
00000000
00000000
00000011
00000011
00000011
00000011
NAME person on gurney4

TIL 1v
11111111
00011000
00011000
11111111
11111111
00011000
00011000
00011000
NAME cross on ambulance

TIL 1w
01111110
01111110
01111110
01111110
01100110
01100110
01100110
11101110
NAME paramedic1

TIL 1x
00111000
01111110
01111111
11011111
10001111
01011110
01111110
01111110
NAME paramedic2

TIL 1y
00000000
00000000
00000000
10000000
11000000
11000000
11000000
11000000
NAME paramedic3

TIL 1z
00000000
00000000
00110000
00111111
00011111
00000000
00000000
00000000
NAME paramedic4

TIL 2a
00111111
01000000
10000110
10001001
10111001
11000110
11001000
10110000
NAME cheese4
WAL true

TIL 2b
00110000
01001000
01001000
00110000
00000110
00001001
01001001
00000110
NAME cheese5
WAL true

TIL 2c
00000001
00000001
00011001
00100101
00100101
00011001
00000001
00000001
NAME cheese6
WAL true

TIL 2d
10001100
10010010
10010010
10001100
10110000
11001000
11001000
10110000
NAME cheese7
WAL true

TIL 2e
11111111
00000000
00100110
00001001
00001001
00000110
00100000
00000000
NAME cheese8
WAL true

TIL 2f
00000000
00001100
00010010
00010010
01001100
10100000
01000000
11111111
NAME cheese9
WAL true

TIL 2g
10111011
01100000
10010000
10110110
01101001
00001011
00000110
11011101
>
01110111
01100000
11010000
10010110
01101101
00001001
00000110
10111011
NAME conveyer belt1
WAL true

TIL 2h
11110000
01111000
00011100
00011110
01101111
10010011
10110011
01100001
>
11110000
00101101
00111100
00011111
01100111
11010111
10010011
01100001
NAME conveyer belt2
WAL true

TIL 2i
00000000
00000000
00000000
00000000
00100000
01111010
11111111
11111111
>
00000000
00000000
00000000
00100000
00000100
01101111
11111111
11111111
NAME melted1
WAL true

TIL 2j
10000110
01001001
00001011
00010110
00001000
00000000
00000010
00000001
>
10000110
00001101
00101001
00010110
00000000
00000100
00000010
00000001
NAME conveyer belt3
WAL true

TIL 2k
11111000
00001100
01101110
10010110
10110111
01101001
00000001
11100001
>
11111000
00011100
01100110
11010110
10010111
01101001
00010101
11000000
NAME conveyer belt4
WAL true

TIL 2l
00000000
00000000
00000000
00000000
00000000
10000000
11110000
11110000
>
00000000
00000000
00000000
00000000
00000000
10000000
11100000
11110000
NAME melted2
WAL true

TIL 2m
00000111
00000000
00010110
00101101
00101001
00010110
00001000
00000011
>
00000111
00001000
00000110
00101001
00101011
00010110
00001000
00000101
NAME conveyer belt5
WAL true

TIL 2n
00000001
00000001
00000000
00000001
00000001
00000000
00000001
00000001
>
00000001
00000000
00000001
00000000
00000001
00000001
00000001
00000001
NAME melted3
WAL true

TIL 2o
10000000
10111110
10001000
10111110
10000000
10111110
10101010
11111111
NAME cheese bucket1
WAL true

TIL 2p
00000000
00000000
00000000
11111111
10000000
10011100
10100010
10100010
NAME cheese bucket2
WAL true

TIL 2q
00000000
00000000
00000000
11111100
00001010
00001010
00001010
00001010
NAME cheese bucket3
WAL true

TIL 2r
00001010
00001010
00001010
00001010
00001010
00001111
00001111
11111111
NAME cheese bucket4
WAL true

TIL 2s
00000000
00000000
00000000
00000000
00000100
11010000
11111000
11111110
>
00000000
00000000
00000000
00000000
00000000
11010000
11111100
11111111
NAME cheese bucket5
WAL true

TIL 2t
10000000
11000000
11100000
01010000
10100000
01111100
00000000
00000000
>
10000000
11000000
11100000
10100000
01010000
01111110
00000000
00000000
NAME melted4
WAL true

TIL 2u
00011000
11111111
11111111
11111111
00011000
00001100
00000111
00000011
NAME accident body1
WAL true

TIL 2v
00000000
00000000
00000000
00000000
00000000
00000011
00000111
00001100
NAME accident body2
WAL true

TIL 2w
00000000
00111111
11100001
11001111
00011100
01110000
01100000
00000000
NAME accident body3
WAL true

TIL 2x
00000000
11111111
00110001
00100010
01000100
10001100
11111111
00000000
NAME scaffolding
WAL true

TIL 2y
00100010
00100010
00100010
00100010
00100010
00100010
00100010
00100010
NAME curtain1
WAL true

TIL 2z
00100011
01100010
10100010
10100011
10010010
10001100
11111111
00000000
NAME curtain2
WAL true

TIL 3a
11111111
11111100
11110000
11100000
11000000
00000000
00000000
00000000
>
11111111
11111110
11111000
11100000
10000000
00000000
00000000
00000000
NAME blood3
WAL true

TIL 3b
11111111
01111111
01001111
00001111
01000011
00000011
00000010
00000000
>
11111111
01111111
01001111
00001111
00000011
00000011
00000000
01000010
NAME blood4
WAL true

TIL 3c
00000000
01111100
01111110
11111111
11111111
01111111
00111110
00011100
>
00000000
01100000
11111110
11111111
11111111
00111111
00011111
00011000
NAME blood5
WAL true

TIL 3d
11111111
10000011
10000001
00000000
00000000
10000000
11000001
11100011
>
11111111
10011111
00000001
00000000
00000000
11000000
11100000
11100111
NAME blood6
WAL true

TIL 3e
00000000
00000000
10000000
11100000
11100000
11110000
11111100
11111100
>
00000000
00000000
11000000
11000000
11100000
11110000
11111000
11111100
NAME blood7
WAL true

TIL 3f
00000000
00000000
00000000
00000001
00000001
00000011
00000011
00011111
NAME blood8
WAL true

TIL 3g
00110000
00011100
00000100
01000110
00110011
00011000
00001100
00000100
>
00110000
00011000
01001100
01000100
00110111
00010000
00011100
00000100
NAME blood9
WAL true

TIL 3h
00001111
00111111
01111111
01111111
00111111
00111111
00011111
00000111
>
00001111
00011111
01111111
01111111
00111111
00111111
00111111
00000111
NAME blood10
WAL true

TIL 3i
11000000
11111100
11111100
11111110
11111110
11111110
11111110
11111111
>
11100000
11111000
11111100
11111100
11111110
11111110
11111110
11111111
NAME blood11
WAL true

TIL 3j
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME invisiwall
WAL true

TIL 3k
10011001
10001001
11111111
10000001
11111111
10000001
11111111
10000001
NAME gallows2 cut
WAL true

TIL 3l
00000000
00111100
01001010
11000011
11000011
01001010
00111100
00000000
NAME dropped body1

TIL 3m
00000000
10011000
11000100
01111111
01111111
11000100
10011000
00000000
NAME dropped body2

TIL 3n
00000000
00000001
00000001
00000010
00000100
00010010
00001010
01010001
>
00000001
00000100
00001010
00010001
00000101
01101001
00100101
01010010
NAME brain material2
WAL true

TIL 3o
10000000
00000000
01000000
10011000
10100100
10010100
10001010
01010001
>
00000000
10000000
10110000
01100100
01010000
10101010
10100100
01010010
NAME brain material3
WAL true

TIL 3p
00000000
00000000
00000000
00000000
10000000
10000010
10001010
01010001
>
00000000
00000000
00000000
00000000
00000000
10000001
10100101
01010010
NAME brain material4
WAL true

TIL 3q
01111110
10000001
10111101
11000011
11000011
10111101
11111111
10000001
NAME bed1

TIL 3r
10000001
10000001
10000001
10000001
10000001
01111110
00000000
00000000
NAME bed2

TIL 3s
00001000
00001000
00010011
00111100
11000000
00000000
00000000
00000000
NAME wire

TIL 3t
00000000
11111111
10000001
10010001
10101011
11000101
11111111
00001000
>
00000000
11111111
10000001
11000101
10101011
10010001
11111111
00001000
NAME monitor
WAL true

TIL 3u
11010000
00010000
00010000
01010100
00111000
00010000
00101000
01000100
NAME iv1
WAL true

TIL 3v
00000000
01110100
10011010
10011010
10011010
01110100
00010000
00110000
NAME iv2
WAL true

TIL 3w
00000001
00001110
11110000
00000000
00000000
00000000
00000000
00000000
NAME wire2

TIL 3x
00000001
00000010
00000111
00001010
00011111
00100100
01111111
10010000
NAME roof1
WAL true

TIL 3y
10000000
01000000
11100000
00010000
11111000
00000100
11111110
10010001
NAME roof2
WAL true

TIL 3z
11111111
10010000
11111111
00000100
11111111
00100000
11111111
10010000
NAME roof3
WAL true

TIL 4a
00000000
00000000
00000000
00000000
00000000
00011111
01111111
11111111
>
00000000
00000000
00000000
00000000
00000000
00110111
11111111
11111111
NAME poop bucket5
WAL true

TIL 4b
00000000
00000000
01000000
11000000
11000000
11110000
11111000
11111110
>
00000000
00000000
01000000
11000000
11100000
11110000
11111000
11111100
NAME melted7
WAL true

TIL 4c
00000000
00000000
00000000
00000000
00000001
00000111
00011111
01111111
>
00000000
00000000
00000000
00000000
00000011
00000011
00111111
01111111
NAME melted8
WAL true

TIL 4d
00010110
00110010
10100101
01000101
10001011
11001010
11110001
01100111
>
00010110
00110100
01100101
01001101
01001011
11011010
11110010
01100111
NAME running poop

TIL 4e
11111111
11111111
01110101
01000101
10001011
11001010
11110001
01100111
>
11111111
11111111
01111101
01011101
01001011
11011010
11110010
01100111
NAME running poop2

TIL 4f
00100000
01100001
11001001
10011001
10010010
10010111
11010101
01110110
>
00100000
01100001
11001001
10011001
10010010
10010011
11010101
01100111
NAME running poop3

TIL 4g
01111110
01000010
01000010
01000010
01111110
10010001
10111101
01111110
NAME toilet1
COL 2

TIL 4h
00000000
00000000
00000000
00010000
00010000
01010100
00111000
00010000
NAME down arrow

TIL 4i
00010000
00111000
01010100
00010000
00010000
00000000
00000000
00000000
NAME up arrow

TIL 4j
00000000
11111111
00000010
00000010
11111111
00010000
00010000
00000000
NAME stage floor4

TIL 4k
00000000
00000000
00000000
00000000
00010000
00000000
00000000
00000000
>
00000000
00000000
00000000
00010000
00101000
00010000
00000000
00000000
NAME brain floor 2

TIL 7r
01111110
01000010
01000010
01000010
01111110
10001001
10111101
01111110
NAME toilet2
COL 2

TIL 7s
01111110
01000010
01010010
01000010
01111110
10001001
10111101
01111110
NAME toilet3
COL 2

TIL ke
11111111
10000000
10000000
10000000
10000000
10000000
10000000
11111111
NAME outside window1
WAL true

TIL kf
11111111
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME outside window2
WAL true

TIL kg
11111111
00000001
00000001
00000001
00000001
00000001
00000001
11111111
NAME outside window3
WAL true

TIL kh
11111111
10000001
10000001
11111111
10000001
10000001
10000001
11111111
NAME outside window4
WAL true

TIL ki
11111000
00000100
10000100
00100100
11000100
00100100
00000100
11111000
NAME coma bed1
WAL true

TIL kj
11111111
10001000
10001001
10111110
10111111
10111010
10001001
11111111
NAME coma bed2
WAL true

TIL kk
00010000
00011000
00010100
01010110
00111010
00010001
00101001
01000101
NAME iv coma1
WAL true

TIL kl
00000000
01110100
10011010
10011010
10011010
01110100
00010000
00010000
NAME iv coma2
WAL true

TIL km
01111111
01001010
01001010
01001010
01001010
01001010
01001010
01111110
>
01111111
01001010
01001010
01001010
01010010
01001010
01001010
01111110
NAME monitor coma
WAL true

TIL ko
00100000
00100000
00100000
00100000
00111100
00100100
00100100
00000000
NAME chair2
WAL true

TIL kp
11111000
00000100
00000100
00000100
00000100
00000100
00000100
11111000
NAME sideways bed1

TIL kq
11111111
10011010
10100110
10100110
10100110
10100110
10011010
11111111
NAME sideways bed2 coma

TIL kr
01111111
01001010
01010010
01001010
01000110
01001010
01010010
01111110
>
01111111
01001010
01000110
01001010
01010010
01001010
01000110
01111110
NAME monitor coma2
WAL true

TIL ks
01000000
00100000
00100000
00010000
00010000
00001000
00011100
00101010
NAME broom1
WAL true

TIL kt
00010000
00010000
00010000
00010000
00010000
00010000
00111000
01010100
NAME broom2
WAL true

TIL ku
00000000
00111000
00101000
01111100
01000100
01000100
00111000
00000000
NAME closet bucket
WAL true

TIL kv
00000011
00001111
00011111
00111111
01111111
01111111
11111111
11111111
NAME corner1
WAL true

TIL kw
11000000
11110000
11111000
11111100
11111110
11111110
11111111
11111111
NAME corner2
WAL true

TIL kx
11111111
11111111
11111110
11111110
11111100
11111000
11110000
11000000
NAME corner3
WAL true

TIL ky
11111111
11111111
01111111
01111111
00111111
00011111
00001111
00000011
NAME corner4
WAL true

TIL kz
11111111
10011000
10100101
10100001
10100101
10011000
10000000
11111111
NAME congrats1

TIL l0
11111111
11001110
00101001
00101001
00101001
11001001
00000000
11111111
NAME congrats2

TIL l1
11111111
00110000
01001010
01001001
00111001
00001001
00110000
11111111
NAME congrats3

TIL l2
11111111
00000000
11001100
00100010
00001110
00010010
00001110
11111111
NAME congrats4

TIL l3
11111111
01000011
01000100
11100011
01000000
01010011
00100000
11111111
NAME congrats5

TIL l4
11111110
00010010
00111010
00111010
10010010
00000010
00010010
11111110
NAME congrats6

TIL l5
00111000
01001100
01000100
01000100
00111000
00010000
00010000
00001000
>
00000000
00111000
01001100
01000100
01000100
00111000
00010000
00100000
NAME balloon

TIL l6
01001101
01010011
01010011
01010011
01010011
01001101
00111111
00000000
NAME apartment bed1

TIL l7
00000001
00000001
00000001
00000001
00000001
00000001
11111110
00000000
NAME apartment bed2

TIL l8
00000000
00111111
01011001
01100101
01100101
01100101
01100101
01011001
NAME apartment bed3

TIL l9
00000000
11111110
00000001
00000001
00000001
00000001
00000001
00000001
NAME apartment bed4

TIL la
00000000
01000000
00011100
00100010
00011010
01000100
10100000
01000000
>
00000000
00000000
00000000
00011000
00000100
00000000
01000000
00000000
NAME brain floor inverted1

TIL lb
00000000
00000000
00000000
00010000
00101000
00010000
00000000
00000000
>
00000000
00000000
00000000
00000000
00010000
00000000
00000000
00000000
NAME brain floor inverted2

TIL lc
01010001
10101100
10101010
01101001
01010101
10101000
10100101
01010010
>
10011010
00100101
01001001
10010010
00100100
10010010
10001010
01010001
NAME brain material inverted
WAL true

TIL ld
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME street solid
COL 2

TIL 1h
00000100
00000110
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 10

TIL 4l
10000001
00000011
00000111
00000111
00000011
10000010
00000001
00000000
NAME title screen 11

TIL 4m
11111111
11111111
11111111
11111111
01111111
11111111
11111111
11111111
NAME title screen 12

TIL 4n
11111111
11111111
11111111
11111111
11111110
11111111
11111101
11111111
NAME title screen 13

TIL 4o
11110000
11111000
11111000
11100100
11111000
11111100
11001100
11000001
NAME title screen 14

TIL 4p
11000000
11000000
01110000
00110000
01000000
01000000
01000000
10000000
NAME title screen 15

TIL 4q
00000000
00000000
00000000
00000000
00000000
00001000
00001000
00000011
NAME title screen 16

TIL 4r
00000001
00000011
00000001
00000011
00001111
00000111
00000111
10000011
NAME title screen 17

TIL 4s
11111110
11111010
11111100
11111100
11111100
11111000
10100111
10000111
NAME title screen 18

TIL 4t
11000001
11000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 19

TIL 4u
10000000
10100000
00110110
00111100
00001100
00000111
00000011
00110011
NAME title screen 20

TIL 4v
00000111
00001111
00000001
00000000
00000000
10000000
10000000
11000000
NAME title screen 21

TIL 4w
10000111
00001111
11111111
11111111
10001111
00001111
11111111
11111111
NAME title screen 22

TIL 4x
01110000
11111000
11111100
11110000
11110000
10111000
11110110
11110100
NAME title screen 23

TIL 4y
00000000
00000000
00000000
00000000
00000000
11100000
00000000
00011000
NAME title screen 24

TIL 4z
00110000
00010000
00010000
01100000
01100000
00010000
00001100
00001111
NAME title screen 25

TIL 5a
11111111
11111111
11111101
11111001
11110000
11100000
10010000
00000000
NAME title screen 36

TIL 5b
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 37

TIL 5c
00000111
00000110
00000011
00000011
00000011
00000110
00000110
00000110
NAME title screen 38

TIL 5d
11001111
11111111
00111111
11111111
00111111
00111111
00111011
00011111
NAME title screen 39

TIL 5e
11111111
11111111
11111111
11111111
11111111
10111111
11011111
11111111
NAME title screen 40

TIL 5f
11111110
11111100
11111000
11110100
11100100
11000000
11000000
10000000
NAME title screen 41

TIL 5g
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000011
NAME title screen 42

TIL 5h
00001100
00001111
00001111
00011111
00111111
01111111
11111111
11111111
NAME title screen 43

TIL 5i
11110111
11111111
11111111
11110111
11111111
11111111
11111111
11111111
NAME title screen 44

TIL 5j
11111111
11111110
11111101
11111010
11110000
11110000
11100000
11110000
NAME title screen 45

TIL 5k
00000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 46

TIL 5l
00000111
00000011
00000001
00000010
00000001
00000011
00000011
00001111
NAME title screen 47

TIL 5m
11111111
11111111
11111110
11111110
11111100
11111110
11111101
11111000
NAME title screen 48

TIL 5n
10000000
00000000
00000000
11000000
10000000
00000000
00000000
00000000
NAME title screen 49

TIL 5o
00111111
00111111
01111111
01111111
01111111
01111111
11111111
11111111
NAME title screen 50

TIL 5p
11111000
11111000
11111000
11111100
11100100
11000000
11110011
11111100
NAME title screen 51

TIL 5q
00000111
00001111
00001111
00000011
00000001
00000000
00000001
00000000
NAME title screen 52

TIL 5r
11111111
11111111
11111111
11111111
11111111
01111111
00011110
00000110
NAME title screen 53

TIL 5s
11111100
11101110
11110111
11111110
11111111
11111110
11111000
11111111
NAME title screen 54

TIL 5t
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11000000
NAME title screen 55

TIL 5u
00000011
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 56

TIL 5v
11111111
00011111
00011111
00011111
00000011
00000011
00000011
00000011
NAME title screen 57

TIL 5w
11111111
11111111
11110110
11110000
11110000
11110000
11110000
11110000
NAME title screen 58

TIL 5x
11111111
11111111
01111111
00100111
00000011
00000011
00000110
00001110
NAME title screen 59

TIL 5y
11110000
11110110
11111011
11111011
00110011
00110000
00110000
01000000
NAME title screen 60

TIL 5z
01111111
11111111
11111111
11111111
11111111
01111111
01111111
01111111
NAME title screen 61

TIL 6a
11010011
11110111
11111111
11111111
11111111
11111111
11111111
11111111
NAME title screen 72

TIL 6b
10011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME title screen 73

TIL 6c
11000000
11000000
11100000
11000000
11100000
11110001
11110011
11111111
NAME title screen 74

TIL 6d
00001110
00001110
00000100
00000000
00000000
10000000
11000000
11110011
NAME title screen 75

TIL 6e
00001111
00111111
01111111
11111111
01111111
01111111
11111111
11111111
NAME title screen 76

TIL 6f
10110000
10111110
10111111
11111111
11111111
11111111
11111111
11111111
NAME title screen 77

TIL 6g
01111111
11111111
11111111
01111111
11111111
11111111
11111111
11111111
NAME title screen 78

TIL 6h
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111111
NAME title screen 79

TIL 6i
11110011
11110011
11111111
11111111
11111111
11111111
11111111
11111111
NAME title screen 80

TIL 6j
00000000
00010000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 81

TIL 6k
00000000
00000000
00000000
00000000
00011000
11100111
11000101
00000000
NAME title screen 82

TIL 6l
00000000
00000000
00000000
00000000
00000001
00010000
00111000
00000010
NAME title screen 83

TIL 6m
00000000
00000000
00000000
00000000
00000000
10000000
11000000
10000000
NAME title screen 84

TIL 6n
00000000
00000000
00000000
00111111
00111111
00000110
00000110
00000110
NAME title screen 85

TIL 6o
00000000
00000000
00000110
11100110
11100110
00000110
00000110
00000110
NAME title screen 86

TIL 6p
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000001
NAME title screen 87

TIL 6q
00000000
00000000
00000000
00000000
00000000
00000000
11110000
11110000
NAME title screen 88

TIL 6r
00000011
00000011
00011111
00011101
00001111
00000111
00000011
00000001
NAME title screen 89

TIL 6s
00000000
00000000
11000000
11100000
11100000
11111000
11111000
11111000
NAME title screen 90

TIL 6t
00000011
00000011
00000111
00001111
00001110
00000110
00000100
00000000
NAME title screen 91

TIL 6u
10000000
10000000
11000000
11000000
00000000
00000000
00000000
00000000
NAME title screen 92

TIL 6v
00000110
00000110
00000110
00000110
00000110
00000110
00000000
00000000
NAME title screen 93

TIL 6w
00000110
00000111
00000111
00000111
00000110
00000010
00000000
00000000
NAME title screen 94

TIL 6x
01000011
11100011
11100011
01100011
01110011
00100001
00000000
00000000
NAME title screen 95

TIL 6y
00110000
01110000
11100000
11000000
10000000
11110000
11110000
00000000
NAME title screen 96

TIL 6z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME title screen 97

TIL 7a
00000000
00000000
00000000
00000000
00000000
00000011
00000111
00000110
NAME title screen 108

TIL 7b
00000000
00000000
00000000
00000000
00000000
10000000
11000000
01100000
NAME title screen 109

TIL 7c
00000000
00000000
00000000
00000000
00000000
00000000
11000000
00000000
NAME title screen 110

TIL 7d
00000000
00000001
00000001
00000011
00000111
00001110
00001101
00011100
NAME title screen 111

TIL 7e
01111000
11110000
11110001
11100011
01100010
00011101
00011111
00111111
NAME title screen 112

TIL 7f
10000111
00011111
00011111
00111111
00111111
11111111
10111110
00111100
NAME title screen 113

TIL 7g
11000000
11000000
11000000
10000010
00000110
00001000
00001000
00000111
NAME title screen 114

TIL 7h
00000000
00000000
00001000
00001000
00001000
00001000
00000000
00010000
NAME title screen 115

TIL 7i
00000110
00000110
00000110
00000111
00000111
00000110
00000111
00000111
NAME title screen 116

TIL 7j
01100000
01100001
11100011
11110011
11110011
00110001
01110001
11100000
NAME title screen 117

TIL 7k
00000000
00010000
00110000
00110000
10110000
11110001
11100001
11000001
NAME title screen 118

TIL 7l
00111000
01111000
11100000
11000000
11000000
10000000
10000000
10000001
NAME title screen 119

TIL 7m
00000000
00000000
00111000
01111000
11111100
11001100
10001100
10001100
NAME title screen 120

TIL 7n
00000000
01000000
01000000
11000001
11000011
11000011
01000010
00000110
NAME title screen 121

TIL 7o
00000001
00000001
11100011
11100011
11110011
00110001
00110000
00110000
NAME title screen 122

TIL 7p
11000000
11100000
11100000
01110000
11110000
11110000
00100000
01100000
NAME title screen 123

TIL 7q
00000000
00000000
00000001
00000000
00000000
00000000
00000000
00000000
NAME title screen 124

TIL 7t
00011100
01111101
11111111
00001111
00000111
00000000
00000000
00000010
NAME title screen 125

TIL 7u
01111110
11111110
11111110
00111110
11111111
11111110
00001110
00001111
NAME title screen 126

TIL 7v
00111100
00111100
11111000
11011000
00011000
00111000
00111000
01110011
NAME title screen 127

TIL 7w
00000111
00000111
10001001
00011011
00011111
10011111
00011111
00111111
NAME title screen 128

TIL 7x
00100000
00000000
11000000
11000000
10000000
10010000
10100000
11000000
NAME title screen 129

TIL 7y
11000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 130

TIL 7z
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 131

TIL 8a
00000000
00000000
00000000
00000000
00000000
10000000
10000000
10001000
NAME title screen 142

TIL 8b
00001001
00000101
00000101
00000101
00000101
00000111
00000111
00000111
NAME title screen 143

TIL 8c
11110110
10111100
11011100
11011100
11011100
10011100
10011100
11111110
NAME title screen 144

TIL 8d
00000000
00000100
00000010
00000011
00000000
00000000
00000000
00000000
NAME title screen 145

TIL 8e
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME title screen 146

TIL 8f
10000000
10000000
10000000
10000000
10000001
11000001
11111001
11111001
NAME title screen 147

TIL 8g
00000001
00000001
01110001
11111001
10011001
10011000
11111000
11110000
NAME title screen 148

TIL 8h
11000001
10000001
10000001
11111001
11111001
11110001
00000001
00000000
NAME title screen 149

TIL 8i
10011000
10110000
11110001
11110001
11111000
10111000
10010000
00000000
NAME title screen 150

TIL 8j
01111000
11111000
11000000
11100000
11110000
01111000
11110000
11100000
NAME title screen 151

TIL 8k
00000111
00000111
00000111
00000111
00000111
00000111
00000111
00000011
NAME title screen 152

TIL 8l
11111111
10111111
00011111
00011111
00000111
00000011
00000000
00000000
NAME title screen 153

TIL 8m
00000000
00000000
11000000
11100000
11111000
11111111
11111111
00111111
NAME title screen 154

TIL 8n
00000000
00000000
00000000
00000000
00000100
10001100
11111000
11100000
NAME title screen 155

TIL 8o
01000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 156

TIL 8p
00000011
00000011
00000011
00000011
00000001
00000001
00000001
00000001
NAME title screen 157

TIL 8q
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000000
NAME title screen 158

TIL 8r
00000011
00000111
00001100
00011000
00010100
00110000
00101000
01100000
NAME title screen 159

TIL 8s
00000001
00000001
00000001
00000001
00000001
00000000
00000000
00000000
NAME title screen 160

TIL 8t
10000000
10000000
00000001
00000001
10000001
10000010
10000010
00000000
NAME title screen 161

TIL 8u
01000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 162

TIL 8v
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00000111
NAME title screen 163

TIL 8w
00000000
00000000
00000001
00000111
00011111
01111111
11111111
11111111
NAME title screen 164

TIL 8x
00010000
01110000
11111000
11111000
11111100
11111100
11111000
01100000
NAME title screen 165

TIL 8y
00000100
00000100
00000000
00001000
00001000
00000000
00010000
00000000
NAME title screen 166

TIL 8z
00011111
01111111
11111111
11111111
11111111
11111011
11101100
11110000
NAME title screen 167

TIL 9a
11111111
11111111
11111111
11111100
11110000
11000000
00000000
00000000
NAME title screen 178

TIL 9b
11110000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 179

TIL 9c
00000000
00000000
00000000
00000000
00000011
00000010
00000010
00000011
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 180

TIL 9d
00000000
00000000
00000000
00000000
10000000
11000000
11000111
10000110
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 181

TIL 9e
00000000
00000000
00000000
00000000
00000000
00011100
00101100
00101100
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 182

TIL 9f
00000000
00000000
00000000
00000000
00000000
00000000
01110001
11100011
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 183

TIL 9g
00000000
00000000
00000000
00000000
00000000
00000000
11000000
10000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 184

TIL 9h
00000000
00000000
00000000
00000000
00000000
00000001
00000001
01111111
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 185

TIL 9i
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11110000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 186

TIL 9j
00000010
00000010
00000010
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 187

TIL 9k
00001100
00001100
00001000
00001000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 188

TIL 9l
00111000
00110000
00111100
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 189

TIL 9m
11100011
01110001
01110001
11000011
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 190

TIL 9n
10000000
11000000
11000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 191

TIL 9o
01111111
00000001
00000001
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 192

TIL le
11110000
11000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen 193

SPR 10
01010110
10111101
01011010
10011001
00111100
01011010
00011000
00100100
NAME corner brother2
DLG SPR_c
POS 9 7,7

SPR 11
00000000
00000000
01000010
01111110
00111100
00011000
00011000
00111100
NAME trophy
DLG SPR_b
POS 9 8,7

SPR 12
00001000
00010000
11111111
10000011
10000001
10000001
11111111
01000010
NAME TV 2
DLG SPR_1t
POS a 9,7

SPR 13
00000001
00000001
00000001
00000001
00011111
00011111
00011111
00011111
>
00000001
00000001
00010101
00000001
00011111
00011111
00011111
00011111
>
00010001
00000101
00000001
00000001
00011111
00011111
00011111
00011111
NAME stove 2
DLG SPR_1v
POS a 14,7

SPR 15
00000000
00010000
01101001
11111110
11111110
01101001
00010000
00000000
>
00000000
00010000
01101001
11111110
11111110
01101001
00010000
00000000
NAME dead brother 2
DLG SPR_1u
POS a 6,9

SPR 16
00000000
00000011
00011111
00110011
00100000
01100000
01000000
10000000
NAME hairdryer 2
DLG SPR_k
POS a 1,7

SPR 17
01111000
11111100
11111110
10101110
10000110
10000110
10000110
10000100
NAME wig1
DLG SPR_14
POS b 5,7

SPR 18
00011100
00111110
01111110
01010110
01000110
11000111
11000011
00000000
NAME blood wig
DLG SPR_e
POS c 7,6

SPR 19
01000000
10100000
00100000
00110100
00011010
00011000
00011000
00111100
>
01000000
00100000
00100010
00110100
00011000
00011000
00011000
00011000
NAME neuron1
DLG SPR_16
POS 1 5,5

SPR 20
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title wall lower
POS 16 -1,2

SPR 21
00111100
00111100
00011001
01111001
10011110
10011000
00010100
00110110
NAME hint
DLG SPR_r
POS i 1,3

SPR 23
10111101
01111110
11111111
00100100
00100100
01100110
11101110
10101010
NAME model1
DLG SPR_s
POS e 0,5

SPR 24
00111100
00111100
00011000
01100110
11111111
01100110
10011001
10111101
NAME model2
DLG SPR_t
POS e 0,4

SPR 25
11000011
10100101
10000001
10100101
10111101
00000000
00100100
11100111
NAME poopman outside
DLG SPR_j
POS 11 6,13

SPR 30
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME end door
DLG SPR_v
POS 12 15,7
COL 1

SPR A
00000000
01000010
00100100
00011000
10111101
00011000
00100100
01000010
>
00000000
01000010
00100100
00000000
01011010
00000000
00100100
01000010
POS 16 -1,1

SPR b
00001000
00010000
11111111
10000011
10000001
10000001
11111111
01000010
NAME TV
DLG SPR_1
POS 0 9,7

SPR c
00000001
00000001
00000001
00000001
00011111
00011111
00011111
00011111
>
00000001
00000001
00010101
00000001
00011111
00011111
00011111
00011111
>
00010001
00000101
00000001
00000001
00011111
00011111
00011111
00011111
NAME stove
DLG SPR_2
POS 0 14,7

SPR e
00000000
00100000
10010110
01111111
01111111
10010110
00001000
00000000
NAME dead brother
DLG SPR_4
POS 0 6,9

SPR f
00000000
00000011
00011111
00110011
00100000
01100000
01000000
10000000
NAME hairdryer
DLG SPR_5
POS 0 1,7

SPR g
00000000
00000000
00111000
01101100
00111100
00001100
00111000
00011000
NAME court audience1
DLG SPR_1i
POS 2 11,11

SPR h
00000000
00000000
00111000
01101100
00111100
00011100
00111100
00011000
>
00000000
00000000
00111000
01101100
00111100
00011100
00111100
00011000
NAME court audience2
DLG SPR_1j
POS 2 12,9

SPR i
00000000
00000000
00000000
00011000
00111100
00111100
00111100
00011000
NAME court audience3
DLG SPR_1k
POS 2 9,9

SPR j
00000000
00000000
00011100
00110100
00111110
00110000
00111100
00011000
NAME court audience4
DLG SPR_1g
POS 2 4,9

SPR k
00000000
00000000
00000000
00011000
00111100
00111100
00111100
00011000
NAME court audience5
DLG SPR_1h
POS 2 7,9

SPR l
11111000
10101000
11111000
01010000
01110000
00100000
11111110
01110001
>
11111000
10101000
11111000
01010000
01110000
00100000
11111110
01110001
NAME judge1
DLG SPR_1m
POS 2 8,3

SPR m
00000000
00000000
00001100
00001100
00001100
00000010
00000001
00000000
>
00000000
00000000
00000000
00000000
00000000
00001100
00001111
00001100
NAME judge2
DLG SPR_1l
POS 2 7,3

SPR n
00011100
00011100
00011100
00001001
00011110
00101000
00001000
00010100
NAME accused
DLG SPR_21
POS 2 9,7

SPR o
00011100
00111010
00011100
00001001
00011110
00011000
00011100
00110110
NAME executioner
DLG SPR_0
POS 3 8,6

SPR p
00001110
00001110
00001110
00000100
00001110
00010101
00001010
00001010
NAME hang audience1
DLG SPR_19
POS 3 11,11

SPR q
00000000
01110000
01110000
01110000
00100000
11110000
00101000
01010000
NAME hang audience2
DLG SPR_1a
POS 3 12,11

SPR r
00000000
10000000
01000000
10001110
10111010
01111110
00111100
00100010
>
00000000
01000000
10000000
10001110
10111010
01111110
00111100
01000100
NAME rat
DLG SPR_1n
POS 5 11,14

SPR s
10001110
11011011
11111111
01111110
00000000
00000000
00000000
00000000
NAME accident
DLG SPR_6
POS 5 9,6

SPR t
00111110
01011101
10101010
01001001
00011100
00101010
00010100
00010100
>
00111110
01011101
10101010
01001001
00111110
00001000
00010100
00010100
NAME pageant1
DLG SPR_1q
POS 8 6,7

SPR u
01011101
00111110
00111110
00011100
00101010
00001000
00010100
00010100
>
01011101
00111110
00111110
00011100
00101010
00001000
00010100
00010100
NAME pageant2
DLG SPR_1r
POS 8 7,7

SPR v
00111110
01011101
00001000
00101000
00011100
00001010
00010100
00010100
>
00111110
01011101
00001000
01001000
00111100
00001010
00010100
00010100
NAME pageant3
DLG SPR_1s
POS 8 8,7

SPR w
00000000
00000000
00011100
00110110
00011110
00000110
10011110
01001100
NAME pageant judge1
DLG SPR_l
POS 8 10,6

SPR x
00011000
00111100
00111100
00011000
00111100
01011010
00011000
00100100
NAME corner brother
DLG SPR_a
POS 8 14,14

SPR y
00000000
00000000
00011100
00110100
00111100
00110000
00111100
00011000
NAME pageant audience
DLG SPR_1p
POS 8 5,11

SPR z
00000000
00000000
00011100
00101110
00011110
00001110
00011110
00001100
NAME pageant judge2
DLG SPR_1o
POS 9 10,6

SPR 1a
01000000
10100000
00100000
00110100
00011010
00011000
00011000
00111100
>
01000000
00100000
00100010
00110100
00011000
00011000
00011000
00011000
NAME neuron2
DLG SPR_1c
POS e 8,2

SPR 1c
00001110
00001110
00001110
00000100
00001110
00010101
00001010
00001010
NAME hang audience3
POS h 11,11

SPR 1d
00000000
01110000
01110000
01110000
00100000
11110000
00101000
01010000
NAME hang audience4
POS h 12,11

SPR 1e
00111100
01000010
10001001
11010101
10001001
10100001
10000101
01111110
NAME hairy cheese
DLG SPR_7
POS 5 14,4

SPR 1f
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME to cheese factory
DLG SPR_8
POS 1 4,9

SPR 1g
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME to pageant
DLG SPR_9
POS 1 11,10

SPR 1h
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME to apartment
DLG SPR_d
POS 1 13,7

SPR 1i
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME to scary hallway
DLG SPR_f
POS a 0,9
COL 1

SPR 1j
01111110
10000010
10000010
10001010
10100010
11110010
10100010
01111110
>
01111110
10000010
10000010
10001010
10000010
10100010
10000010
01111110
NAME to wake up
DLG SPR_g
POS 1 8,8

SPR 1k
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME locked door
DLG SPR_h
POS 0 0,9
COL 1

SPR 1m
00011100
00011100
00011100
00001000
00011100
00101010
00001000
00010100
>
00011100
00011100
00011100
00001000
00011100
00101010
00001000
00010100
NAME player cowboy

SPR 1n
00011100
00101010
00011100
00001001
00011110
00011000
00011100
00110110
NAME executioner2
POS h 8,6

SPR 1p
00001100
00011100
11001100
11010110
11100010
11010111
00011110
00010010
NAME nurse
DLG SPR_22
POS g 10,9

SPR 1q
11000011
10100101
10000001
10100101
10111101
10000000
00100100
11100111
NAME poopman1
DLG SPR_m
POS e 12,10

SPR 1r
11000011
10100101
10000001
10100101
10111101
10000001
00100100
11100111
>
11000011
10100101
10000001
10100101
10111101
10000001
00100100
11100111
NAME poopman2
DLG SPR_i
POS i 11,9

SPR 1s
11000011
10100101
10000001
10100101
10111101
00000001
00100100
11100111
NAME poopman3
DLG SPR_n
POS k 12,12

SPR 1t
00011100
00111110
00011100
00011100
00001000
00011100
00101010
00010100
>
00011100
00111110
00011100
00011100
00101010
00011100
00001000
00010100
NAME player cow2

SPR 1w
00000000
00011100
00111110
01111110
01010110
01000110
11000111
11000011
NAME wig icon

SPR 1x
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title screen special
DLG SPR_q
POS 16 0,1
COL 1

SPR 1y
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title wall upper
POS 16 -1,0

SPR 1z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME title wall left
POS 16 -2,1

SPR 2b
00001000
00010000
11111111
10000011
10000001
10000001
11111111
01000010
NAME TV intensive
DLG SPR_z
POS 11 8,12

SPR 2c
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME to intensive1
DLG SPR_u
POS l 4,10
COL 1

SPR 2e
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME to closet
DLG SPR_w
POS 12 0,8
COL 1

SPR 2f
00001000
00010000
11111111
10000011
10000001
10000001
11111111
01000010
NAME TV intensive won
DLG SPR_1y
POS 13 8,12

SPR 2g
11000011
10100101
10000001
10100101
10111101
10000000
00100100
11100111
>
11000011
10100101
10000001
10100101
10111101
00000001
00100100
11100111
NAME poopman won
DLG SPR_20
POS 13 6,11

SPR 2h
00110000
00111000
00110011
01101011
11000111
01101011
01111000
01001000
NAME nurse won
DLG SPR_1z
POS 13 3,11

SPR 2i
01111110
10000010
10000010
10001010
10000010
10000010
10000010
01111110
NAME unfinished door
DLG SPR_x
POS 11 4,10
COL 1

SPR 2j
00011100
00010100
00001100
11011100
11111100
11011110
00011100
00010100
NAME reporter
DLG SPR_p
POS 12 7,9

SPR 2k
00111000
01010100
00111000
00010000
01111100
10111010
00111000
00101000
NAME won hangman
DLG SPR_o
POS 12 3,7

SPR 2l
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00100100
NAME won audience1
DLG SPR_y
POS 12 5,7

SPR 2m
11000011
10100101
10000001
10100101
10111101
00000001
00100100
11100111
NAME won audience2
DLG SPR_10
POS 12 10,9

SPR 2n
01110000
01110000
01110000
00100000
01110000
10101000
01010000
01010000
NAME won audience3
DLG SPR_1x
POS 12 3,9

SPR 2o
00000000
00001110
00001110
00001110
00000100
00001111
00010100
00001010
NAME won audience4
DLG SPR_1w
POS 12 2,9

SPR 2p
00000000
00000000
00111110
01011101
10100010
01000001
00000000
00000000
NAME recognized wig1
DLG SPR_13
POS b 3,9

SPR 2q
00000000
00000000
10111101
01111110
01111110
00111100
01000010
00000000
NAME recognized wig2
DLG SPR_12
POS b 4,9

SPR 2r
00000000
00000000
00000000
00111110
01011101
00000000
00000000
00000000
NAME recognized wig3
DLG SPR_11
POS b 5,9

SPR 2s
00111000
01111100
11111110
10100110
10000110
10000110
10000010
00000000
NAME scare wig1
DLG SPR_3
POS b 12,9

SPR 2t
00000000
10010010
01111100
11111110
11001010
11000010
01000000
00000000
NAME scare wig2
DLG SPR_15
POS b 2,7

SPR 2u
00000000
00000000
00000000
00000000
00000000
01111100
00000000
00000000
>
00000000
00000000
00000000
00000000
00010000
00101000
00000000
00000000
NAME horton
DLG SPR_1b
POS e 15,14

SPR 2v
00000000
00000000
00000000
00000000
01111110
01001010
01000010
00111100
>
00000000
00000000
00010000
00000000
01111110
01001010
01000010
00111100
NAME mac and cheese
DLG SPR_1d
POS e 15,7

SPR 2w
00000000
01111110
11111111
01010110
01010110
01010110
01010110
00111100
NAME trash
DLG SPR_1e
POS e 1,10

SPR 2x
00000000
00111100
00100100
00011000
11111111
01000010
01000010
00000000
NAME consternation
DLG SPR_1f
POS i 13,11

SPR 2y
00011100
00011100
00011100
00001000
00011100
00101010
00001000
00010100
>
00000000
01000010
00100100
00000000
01011010
00000000
00100100
01000010
NAME tryAgain

SPR 2z
00000000
10000000
01000000
10001110
10111010
01111110
00111100
00100010
>
00000000
01000000
10000000
10001110
10111010
01111110
00111100
00100010
NAME rat 2
DLG SPR_23
POS a 11,5

ITM 2
00000000
00000000
00000000
00001000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00001000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00010000
00000000
00000000
00000000
>
00000000
00000000
00000000
00010000
00000000
00000000
00000000
00000000
NAME mind wandering
DLG ITM_0
COL 3

ITM 3
01111110
01000010
01000010
01000010
01111110
10000001
10000001
01111110
NAME toilet
DLG ITM_1

ITM 4
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME odor PERMANENT
DLG ITM_2

ITM 5
00000000
00000000
00000000
00011000
00000100
00000000
01000000
00000000
>
00000000
01000000
00011100
00100010
00011010
01000100
10100000
01000000
NAME to poop1 PERMANENT
DLG ITM_3
COL 1

ITM 6
00010000
00111000
01010100
00010000
00010000
00000000
00000000
00000000
NAME subtract loop PERMANENT
DLG ITM_4
COL 1

ITM 7
00000000
00000000
00000000
00010000
00010000
01010100
00111000
00010000
NAME add loop PERMANENT
DLG ITM_5
COL 1

ITM b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME scare2 PERMANENT
DLG ITM_8

ITM c
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME scare1 PERMANENT
DLG ITM_9

ITM d
00000010
00100010
00100101
01010010
01010101
10001010
10000010
01000001
>
00000000
01001100
10000100
01010010
01010101
10101010
10000110
01001001
NAME fire UNIQUE
DLG ITM_a
COL 1

DLG SPR_2
I left the apartment to pick up more ingredients and forgot a pot of soup turned a little too high on the stove.

DLG SPR_4
My brother was found lying on the floor, dead. And it was my fault.

DLG SPR_5
My brother's special, fancy hairdryer.{lookedAtHairdryer = 1}

DLG SPR_0
"""
(music "phoneCool")It's been discovered that he was innocent! Quickly, cut the rope!(soundeffect "cutTheRope1")
...(exitNow "gallows2,8,7")(soundeffect "cutTheRope2")
He's down! Someone call an ambulance!
...(exitNow "ambulance,-1,15")
Patient is miraculously still alive, but unresponsive. The EEG shows
...(exitNow "brain hub,2,4")
minimal brain activity.
"""

DLG SPR_6
"""
At the cheese factory where my brother worked, there was an accident. His scalp was scalded with third degree burns.
...(exitNow "dark,8,8")
The doctor said that he would never grow natural hair again. As we left the hospital that day, I saw him look longingly at a nurse's full head of hair. He was never the same person again.(exit "brain hub,4,10")
"""

DLG SPR_7
"""
{
  - cheese == 0 ?
    (soundeffect "memento1"){clr2}This is an important memento.{clr2} My brother was accustomed to bringing home cheese samples from his work. One of them had a huge wad of hair in it.{cheese = 1}
  - else ?
    {clr2}This is an important memento.{clr2} My brother was accustomed to bringing home cheese samples from his work. One of them had a huge wad of hair in it.{cheese = 1}
}
"""

DLG SPR_8
(exitNow "cheese factory,1,12")

DLG SPR_9
"""
{
  - cheese == 1 ?
    (exitNow "hair pageant1,1,13")
  - else ?
    {clr2}You still need to find a memento to go through this door.{clr2}
}
"""

DLG SPR_a
"""
There was my brother, standing jealously in the corner of a friend's hair pageant.


(exitNow "dark,14,13")...(soundeffect "newPageant")(exitNow "hair pageant2,14,13")
"""

DLG SPR_b
"""
{
  - trophy == 0 ?
    (soundeffect "memento2"){clr2}This is an important memento.{clr2} The first of many trophies that my brother won for his taste in wigs.{trophy = 1}
  - else ?
    {clr2}This is an important memento.{clr2} The first of many trophies that my brother won for his taste in wigs.{trophy = 1}
}
"""

DLG SPR_c
And there was my brother, victorious in his first wig. There would be many more; it would become an obsession.(exit "brain hub,11,11")

DLG SPR_d
"""
{
  - trophy == 1 ?
    (exitNow "apartment 2,7,5")
  - else ?
    {clr2}You still need to find a memento to go through this door.{clr2}
}
"""

DLG SPR_h
This door is locked.

DLG SPR_i
"""
{
  - money == 1 ?
    (music "phoneDino")come back soon! if you ate less cheese maybe you would be constipated less(musicEnd "poopSong")
  - {item "toilet"} < 4 ?
    (music "phoneDino")thank you for dropping by. please take a seat and enjoy your stay(musicEnd "poopSong")
  - else ?
    (music "phoneDino")heres your money. and i sincerely thank you{money = 1}(musicEnd "poopSong")
}
"""

DLG SPR_l
Let's give it up for the winners of this week's pageant: Mohawk Mindy, Bouffant Bob, and Hairy Hairy!{hairTalked = 1}

DLG SPR_m
(music "phoneDino")oi! i am the poop purveyor! the poop is overflowing from the poop factory! who will clean it up?(musicEnd "poopSong")

DLG SPR_q
(music "main1")(music "main1Reversed")(music "main2")(music "phoneCool")(music "phoneDino")(music "poopSong")(music "scary")(music "scaryQuieter")(music "cutTheRope1")(music "cutTheRope2")(music "won")(music "memento1")(music "memento2")(music "memento3")(music "memento4")(music "memento5")(music "newPageant")(music "nurseScare")(music "pwet")(music "monitor")(exit "apartment 1,13,7")

DLG SPR_r
"""
{cycle
  - psst... if you go just above that poo crate, your mind will be "wandering" ...
  - it makes you wonder if doing that in random corners enough may have some effect and affect something somewhere...
}
"""

DLG SPR_s
"""
{
  - model == 0 ?
    {
  - {item "mind wandering"}>=5 && soup==1 && wig==1 && monitored==0  ?
    (soundeffect "monitor"){monitored = 1}
}(soundeffect "memento5"){clr2}dis be an important memnto.{clr2} hey there. im a model. a model manikin. i like to model all the newest hats and hairstyles.{model = 1}
  - else ?
    {clr2}dis be an important memnto.{clr2} hey there. im a model. a model manikin. i like to model all the newest hats and hairstyles.{model = 1}
}
"""

DLG SPR_z
...on the good news, activity on the Night Scalper has ceased...

DLG SPR_w
(exitNow "wake up won,10,8")This wasn't a broom closet before, was it?

DLG SPR_x
"""
{
  - talked == 0 ?
    Maybe I have unfinished business here.
  - else ?
    (exit "outside,4,9")
}
"""

DLG ITM_2
"""
{
  - setOdor == 1 ?
    {wvy}the odor of a poop factory wafts from this direction{wvy}{setOdor = 0}
}
"""

DLG ITM_3
{setOdor = 1}{visitedPoop = 1}(exit "poop1,7,0")

DLG ITM_4
"""
{
  - loop == 0 ?
    (exitNow "poop2,3,15")
  - else ?
    {loop = loop - 1}(exitNow "poop5,3,15")
}
"""

DLG ITM_5
{loop = loop+1}(exitNow "poop4,3,0")

DLG SPR_p
"""
{sequence
  - Hello. I am with the press. Falsely accused in the Harts Brothers case is awake. Do you have a statement? ...
  - You say that your brother was the Night Scalper? Hmm. That would be consistent with the fact that there have been no recent Night Scalpings...
}
"""

DLG SPR_y
I'm looking for my wife. She just had a son. I set up the sign outside. Who are all you people??

DLG SPR_10
we always knew ye could do it. come back and visit us sometime, in ye dreams, ye?

DLG ITM_8
"""
{
  - scareCount == 2 ?
    {scareCount = 1}You can feel ghostly eyes staring at you solemnly from under each of the hairpieces.
}
"""

DLG ITM_9
"""
{
  - scareCount == 1 && wig == 0 ?
    {scareCount = 0}I have a really bad feeling about this, like there's a reason I've been suppressing these memories...
}
"""

DLG SPR_3
My brother would be horrified if he knew these wigs were burning. He was always talking about their value.

DLG SPR_14
There's piles of wigs here, each with its own personality.

DLG SPR_15
Where did my brother get this style from?

DLG SPR_17
I am the neuron at the head of a long strand of neurons, with a message for you. Who are you, you might ask? You may have noticed that you are not the accused, nor any other person in this ordeal. You are like one of us, a neuron. One spark, wandering his consciousness. Search the clues. The world’s court of the living has declared your innocence, but you must realize it yourself to return to them. One spark, one neuron firing, to start a fire. Or languish here within your own mind.

DLG SPR_16
I am the neuron at the head of a long strand of neurons, with a message for you. Who are you, you might ask? You may have noticed that you are not the accused, nor any person in this ordeal. You are like one of us, a neuron. One spark, wandering his consciousness. Search the clues. The world's court of the living has declared your innocence, but you must realize it yourself to return to them. One spark, one neuron firing, to light a fire. Or languish here within your own mind.

DLG SPR_18
I am the neuron at the head of a long strand of neurons, with a message for you. Who are you, you might ask? You may have noticed that you are not the accused, nor any person in this ordeal. You are like one of us, a neuron. One spark, wandering his consciousness. Search the clues. The world's court of the living had declared your innocence, but you must realize it yourself to return to them. One spark, one neuron firing, to start a fire. Or languish here within your own mind.

DLG SPR_19
Now Molly, this is what happens if you get on Santa's extra naughty list.

DLG SPR_1a
What are you doing here, Mr. Fireman?

DLG SPR_1b
hi, im horton. im a snail. i feel kind of sad, to be frank

DLG SPR_1d
it's a bowl of mac and cheese (shards of computer parts mixed with melted cheese).

DLG SPR_1e
it's a trashcan full of cheese. what a waste! and a bunch of empty laxative bottles

DLG SPR_1f
the glass of cheese on the table fills you with constipation and consternation

DLG ITM_1
"""
{sequence
  - you ser(soundeffect "pwet")iously took a dump in this toilet..
  - that (soundeffect "pwet")was some chunky cheese, to use a euphemism
  - OHHHHHHH(soundeffect "pwet")
  - (soundeffect "pwet")there's smoke coming off of it! i guess that's how it is when you're an ephemeral spark
  - that poor toilet...(soundeffect "pwet")
}
"""

DLG SPR_1g
Truly murder in the third degree! That's the worst degree, right? The one with the third degree burns!

DLG SPR_1h
Now where am I going to buy my wigs from on Etsy? You monster!

DLG SPR_1j
"""
{cycle
  - You're gonna hang for this! ...
  - Your brother was an artist. And what are you, but a filthy murderer! I hope you like the feeling of being eaten by worms! I'm so angry!
}
"""

DLG SPR_1k
Careless, careless. It's so obvious that it wasn't an accident, that the soup was merely a scapegoat.

DLG SPR_1i
"""
{cycle
  - How could you? Your own brother!
  - How could you do this to your own brother?
}
"""

DLG SPR_11
"""
{
  - hairTalked == 1 ?
    Hmm, this wig looks familiar. Mohawk Mindy?
  - else ?
    Hmm, this wig looks familiar...
}
"""

DLG SPR_13
"""
{
  - hairTalked == 1 ?
    Huh, I recognize this wig... Hairy Hairy?
  - else ?
    Huh, I recognize this wig... from the hair pageant.
}
"""

DLG SPR_12
"""
{
  - hairTalked == 1 ?
    Hmm, I recognize this wig. Bouffant Bob?
  - else ?
    This wig looks familiar...
}
"""

DLG SPR_1l
"""
{
  - judged == 0 ?
    Brother mysteriously dead, despite apartment only half burned, suggests foul play. {shk}The judge slams his gavel.{shk} Guilty of arson and murder. {shk}The judge slams his gavel.{shk} Sentenced to hang by the neck until you are dead! {shk}The judge again slams his gavel.{shk} Today! {shk}The judge concludes with a slamming of his gavel.{shk}{judged = 1}
  - else ?
    {shk}The judge looks you dead in the eye and slams his gavel.{shk}
}
"""

DLG SPR_1m
"""
{
  - judged == 0 ?
    Brother mysteriously dead, despite apartment only half burned, suggests foul play. {shk}The judge slams his gavel.{shk} Guilty of arson and murder. {shk}The judge slams his gavel.{shk} Sentenced to hang by the neck until you are dead! {shk}The judge again slams his gavel.{shk} Today! {shk}The judge concludes with a slamming of his gavel.{shk}{judged = 1}
  - else ?
    {shk}The judge looks you dead in the eye and slams his gavel.{shk}
}
"""

DLG SPR_1n
"""
{sequence
  - Squeak! Cheese factories don't look like this, with giant blocks of cheese everywhere, do they? This is an imagined place. You never visited this part of your brother's work. This is only what a cheese factory looks like in your mind. After all, rats can't talk, but what am I doing right now? Squeak!
  - Squeak! Squeak!
}
"""

DLG SPR_1o
The winner is our, er, only surviving contestant, but nonetheless endlessly inventive...

DLG SPR_1p
Yeah, go Mindy! Love you baby! Don't know what I would do if something happened to you!

DLG SPR_1q
I wore egg yolks in my hair for a week to get this hair, until the eggs turned into solid, cooked eggs. Because my hairstyle is just that hot!

DLG SPR_1r
My bouffant is so bulbous! Ma-ca-dam-ia!

DLG SPR_1s
I would like to thank my parents because without them I wouldn't have been able to have this hair.

DLG SPR_1t
It's turned to the Murder Channel, on a special report on the Night Scalper, a terrifying killer in our area who steals the hair from his victims. My brother had a strange fascination with the killer.

DLG SPR_1u
An autopsy showed that my brother committed suicide, wasn't killed by the fire. How did this fact get into my head? Someone in the waking world must have said it to me...{lookedAtBrother = 1}

DLG SPR_1w
He really made it! He's like Jesus!

DLG SPR_1x
I'm glad you're okay. I brought my daughter to your hanging to teach her about something, and that lesson turned out to be more complicated than I thought it would be. I'm still not sure what exactly it is, though.

DLG SPR_1y
The weather is sunny with a low in the mid-70s. It's a beautiful day!

DLG SPR_1z
"""
{sequence
  - You're looking alive! Have a nice life! ...
  - Since you and I are the only two in this room, between you and me, I'm glad I don't have to clean up after you anymore. In my professional opinion, you've had way too much lactose in your life. Now have a nice life!
}
"""

DLG SPR_20
"""
{cycle
  - we knew you could do it! you're really awake this time, i promise ...
  - ...or are you? you have to beat the game 500 more times to get the real ending.
}
"""

DLG SPR_21
"""
{
  - judged == 0 ?
    There I was, waiting to hear my sentence. Maybe I should've gotten a lawyer.
  - else ?
    So this was it. I was going to die. Maybe I made the mistake of not getting a lawyer.
}
"""

DLG SPR_g
"""
{
  - wig == 1 && soup == 1 && model == 1 ?
  	{clr2}{printSprite "hairy cheese"}  {printSprite "trophy"}  {printSprite "hairdryer"}  {printSprite "wig icon"}  {printSprite "model2"}{clr2}(exit "wake up,5,6")
  - wig == 1 && soup == 1 ?
    {clr2}{printSprite "hairy cheese"}  {printSprite "trophy"}  {printSprite "hairdryer"}  {printSprite "wig icon"}{clr2}(exit "wake up,5,6")
  - else ?
    {clr2}You still need to find a memento to go through this door.{clr2}
}
"""

DLG SPR_1v
Did the stove really cause the fire? I'm almost certain I left it on low.

DLG SPR_1
The TV is turned to another cosmetology show.

DLG SPR_1c
"""
{sequence
  - hi, im a nerve. all hail the poop factory! ...
  - o, you came from brain, are brain cell? such elitist!
}
"""

DLG SPR_22
"""
{sequence
  - {
      - lookedAtBrother == 1 ?
        I've been watching that EEG monitor steadily climbing - and now you're awake! How is your neck? We know that you didn't start the fire. The fire department found a faulty wire ... huh, you already knew that? Well, people have visited and told you things, maybe that's how. People in comas have been known to hear things. The fire isn't even what killed your brother: an autopsy showed that he committed suicide. You knew that too? You wouldn't happen to know why he would want to kill himself over his apartment burning down, would you? ...
      - else ?
        I've been watching that EEG monitor steadily climbing - and now you're awake! How is your neck? We know that you didn't start the fire. The fire department found a faulty wire ... huh, you already knew that? Well, people have visited and told you things, maybe that's how. People in comas have been known to hear things. The fire isn't even what killed your brother: an autopsy showed that he committed suicide. You wouldn't happen to know why he would want to kill himself over his apartment burning down, would you? ...
    }
  - {
      - nurseSounded == 0 ?
        Well, you seem well enough to go. Feel free to check out the intensive care unit on your way out; a man is in a coma in there and{nurseSounded = 1}(music "S")(soundeffect "nurseScare")(musicEnd "main2") he looks just like you!
      - else ?
        Well, you seem well enough to go. Feel free to check out the intensive care unit on your way out; a man is in a coma in there and he looks just like you!
    }
}
"""

DLG SPR_o
"""
{sequence
  - Hey, sorry I hanged you. No hard feelings right? Just doin' the job, ya'know? Also I think I may have tied the rope wrong, which turned out to be a good thing!
  - I have nightmares every day.
}
"""

DLG SPR_j
"""
{cycle
  - This man is comatose; only his brainstem is active. Will he ever wake up? I tell him, "To wake, you must confront the darkest part of yourself. To leave, you must complete all the business." ...
  - {
      - gaveBrainHint == 1 ?
        Your mind wandered {print {item "mind wandering"}} out of 5 times, and you didn't find the primal subconscious. That's unfortunate. It's got to be somewhere in that brain. My guess would be the brain stem.{talked = 1}
      - visitedPoop == 0 ?
        Your mind wandered {print {item "mind wandering"}} out of 5 times, and you didn't find the primal subconscious. That's unfortunate. It's got to be somewhere in that brain.{talked = 1}{gaveBrainHint = 1}
      - model == 0 ?
        Your mind wandered {print {item "mind wandering"}} out of 5 times, and you found the primal subconscious but didn't find the memento there. That's unfortunate.{talked = 1}
      - {item "mind wandering"} >= 7 ?
        (soundeffect "won")Your mind wandered {print {item "mind wandering"}} out of 5 times, and you found the primal subconscious and(exitNow "dark2,0,10") the memento there. Wow! You're a true wanderer. You know you could have woken up sooner if you didn't get so lost in your own head!{talked = 1}(exit "intensive won,3,14")
      - {item "mind wandering"} >= 5 ?
        (soundeffect "won")Your mind wandered {print {item "mind wandering"}} out of 5 times, and you found the primal subconscious and(exitNow "dark2,0,10") the memento there. Wow!{talked = 1}(exit "intensive won,3,14")
      - {item "mind wandering"} <= 3 ?
        Your mind wandered {print {item "mind wandering"}} out of 5 times, and you found the primal subconscious and the memento there. That's unfortunate. Not enough wandering. You'll need to search the corners of your mind.{talked = 1}
      - else ?
        Your mind wandered {print {item "mind wandering"}} out of 5 times, and you found the primal subconscious and the memento there. That's unfortunate. Not enough wandering.{talked = 1}
    }
}
"""

DLG SPR_n
"""
{
  - loop == 0 ?
    (music "phoneDino")tis a wondrous place this endless river is. stay here in your coma and walk this river forever, and listen to the song of the dinos
  - loop == 1 ?
    (music "phoneDino")return from whence ye came, finish ye quest, or stay here and become like an old vegetable(musicEnd "poopSong")
  - loop == 2 ?
    {cycle
      - (music "phoneDino")this river be the sole output of ye existence...and the input be a similar substance ...(musicEnd "poopSong")
      - (music "phoneDino")drip, drip, drip...(musicEnd "poopSong")
    }
  - loop == 3 ?
    (music "phoneDino")no need to fear death when it will be more of the same {shk}62652069206d6f6e737465722c20696e76697369626c652077616c6c2c206f722067
    756964653f2077696c6c20796f75206265206f68656176617420766120757279793f{shk}(musicEnd "poopSong")
  - loop >= 4 ?
    (music "phoneDino")the dark{print loop}ness is f{shk}6c61766f72 6c657373{shk} but so {shk}736d6f6f6f7468{shk}(musicEnd "poopSong")
}
"""

DLG ITM_a
Ouch, this fire burns... or at least it would if I were corporeal.

DLG SPR_23
"""
{sequence
  - Hey, remember me, from the cheese factory? Squea! I'm inhaling so much smoke in here! Squea!
  - Squeak! Squeak!
}
"""

DLG SPR_u
"""
{
  - talked == 0 ?
    The door is labeled: I.C.U.(exit "intensive,4,11")
  - else ?
    (exitNow "intensive,4,11")
}
"""

DLG SPR_v
"""
(exitNow "outside won,16,7")Credits
Game by Max and Seth Levine. Bitsy engine by Adam Le Doux. Borksy, image to bitsy, and other hacks by ayolland, mildmojo, DavidMowatt, Sean S. LeBlanc, and synth_ruiner. Thanks to everyone who made this game possible! And thank you, player, for making it this far!(end "You don't think you will ever fully recover from this. The betrayal of your brother and the stay in the hospital will always be with you, but you can go on with your life.")
"""

DLG SPR_f
"""
{
  - throughFireDoor == 0 ?
    This door had always been locked, but the fire has burned it open.{scareCount = 2}
{throughFireDoor = 1}(exit "scary hallway,14,8")
  - else ?
    {scareCount = 2}
{throughFireDoor = 1}(exit "scary hallway,14,8")
}
"""

DLG ITM_0
"""
{sequence
  - Is your mind wandering?
  - Your mind wanders and you think of the time when you and your brother were kids. Your brother found a lame street kitten about to be cannibalized by its own family. He nursed the kitten back to health.
  - Your mind wanders and you think of the soup you were making, lobster bisque. You think of the old adage about boiling a lobster.
  - Your mind wanders and you think of your brother's only girlfriend. She dumped him for someone who he thought was more attractive.
  - {
  - soup==1 && wig==1 && model==1 && monitored==0  ?
    (soundeffect "monitor"){monitored = 1}
}Your mind wanders and you think of your brother's battle with cancer. One round of intense chemotherapy was luckily enough to keep the sickness from taking over.
  - Your mind wanders and you think of the book your brother was writing. It was a cross between Robin Hood and space pirates.
  - Your mind wanders and you think of the time when you and your brother were kids. Unable to join the school sports teams, he would often become enraptured in acting out hallucinatory fantasies in which he was the fullback, the sprinter, the up to bat...
}
"""

DLG SPR_k
"""
{
  - lookedAtHairdryer == 1 ?
    {
      - soup == 0 ?
        {
  - {item "mind wandering"}>=5 && wig==1 && model==1 && monitored==0  ?
    (soundeffect "monitor"){monitored = 1}
}(soundeffect "memento3"){clr2}This is an important memento.{clr2} The fire department found scald marks around the electrical outlet where the special hairdryer with a slightly frayed cord was plugged in. The fire was on this side of the apartment, not the kitchen. How did this fact get into my head? Someone in the waking world must have told me...{soup = 1}
      - else ?
        {clr2}This is an important memento.{clr2} The fire department found scald marks around the electrical outlet where the special hairdryer with a slightly frayed cord was plugged in. The fire was on this side of the apartment, not the kitchen. How did this fact get into my head? Someone in the waking world must have told me...{soup = 1}
    }
  - else ?
    {
      - soup == 0 ?
        {
  - {item "mind wandering"}>=5 && wig==1 && model==1 && monitored==0  ?
    (soundeffect "monitor"){monitored = 1}
}(soundeffect "memento3"){clr2}This is an important memento.{clr2} The fire department found scald marks around the electrical outlet where a hairdryer with a slightly frayed cord was plugged in. The fire was on this side of the apartment, not the kitchen. How did this fact get into my head? Someone in the waking world must have told me...{soup = 1}
      - else ?
        {clr2}This is an important memento.{clr2} The fire department found scald marks around the electrical outlet where a hairdryer with a slightly frayed cord was plugged in. The fire was on this side of the apartment, not the kitchen. How did this fact get into my head? Someone in the waking world must have told me...{soup = 1}
    }
}
"""

DLG SPR_e
"""
{
  - wig == 0 ?
    {
  - {item "mind wandering"}>=5 && soup==1 && model==1 && monitored==0  ?
    (soundeffect "monitor"){monitored = 1}
}(soundeffect "memento4"){clr2}{shk}This is an important memento.{shk}{clr2} I remember seeing one of the wigs my brother had made - it still had blood caked on its inside, as if it had been torn directly from someone's scalp. I remember all of these murders, every victim with a different color and style of hair. And my brother had worn all of them! My brother must have been the prolific Night Scalper...{wig = 1}
  - else ?
    {clr2}{shk}This is an important memento.{shk}{clr2} I remember seeing one of the wigs my brother had made - it still had blood caked on its inside, as if it had been torn directly from someone's scalp. I remember all of these murders, every victim with a different color and style of hair. And my brother had worn all of them! My brother must have been the prolific Night Scalper...{wig = 1}
}(exit "brain hub,13,8")
"""

DLG SPR_t
"""
{
  - model == 0 ?
    {
  - {item "mind wandering"}>=5 && soup==1 && wig==1 && monitored==0  ?
    (soundeffect "monitor"){monitored = 1}
}(soundeffect "memento5"){clr2}dis be an important memnto.{clr2} hey there. im a model. a model manikin. i like to model all the newest hats and hairstyles.{model = 1}
  - else ?
    {clr2}dis be an important memnto.{clr2} hey there. im a model. a model manikin. i like to model all the newest hats and hairstyles.{model = 1}
}
"""

END 0
Everything goes back to normal. You soon forget you ever had a brother. You forget a lot of things, but as time goes by, everything becomes smoother and smoother. Still, you feel that, somewhere, you left yourself behind.

VAR cheese
0

VAR trophy
0

VAR wig
0

VAR money
0

VAR soup
0

VAR loop
0

VAR model
0

VAR talked
0

VAR setOdor
0

VAR visitedPoop
0

VAR scareCount
0

VAR hairTalked
0

VAR judged
0

VAR lookedAtHairdryer
0

VAR lookedAtBrother
0

VAR nurseSounded
0

VAR gaveBrainHint
0

VAR throughFireDoor
0

VAR monitored
0


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:1.5vw;
	overflow:hidden;
	background:#fffde8;
}

#game {
	background:#fffde8;
	width:94vw;
	max-width:94vh;
	margin:auto;
	display:block;

	/* https://caniuse.com/#search=image-render */
  	-ms-interpolation-mode: nearest-neighbor; /* IE */
  	image-rendering: -moz-crisp-edges; /* FF 6.0+ */
  	image-rendering: pixelated; /* Chrome, Safari */
}

</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
  attachCanvas( document.getElementById("game") );
  load_game( document.getElementById("exportedGameData").text.slice(1) );
}
</script>

<script>
//hex-to-rgb method borrowed from stack overflow
function hexToRgb(hex) {
  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
  var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, function(m, r, g, b) {
    return r + r + g + g + b + b;
  });

  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}
function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function hslToHex(h,s,l) {
    var rgbArr = hslToRgb(h,s,l);
    return rgbToHex( Math.floor(rgbArr[0]), Math.floor(rgbArr[1]), Math.floor(rgbArr[2]) );
}

function hexToHsl(hex) {
    var rgb = hexToRgb(hex);
    return rgbToHsl(rgb.r, rgb.g, rgb.b);
}

// really just a vector distance
function colorDistance(a1,b1,c1,a2,b2,c2) {
    return Math.sqrt( Math.pow(a1 - a2, 2) + Math.pow(b1 - b2, 2) + Math.pow(c1 - c2, 2) );
}

function hexColorDistance(hex1,hex2) {
    var color1 = hexToRgb(hex1);
    var color2 = hexToRgb(hex2);
    return rgbColorDistance(color1.r, color1.g, color1.b, color2.r, color2.g, color2.b);
}


// source : http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
/* accepts parameters
 * h  Object = {h:x, s:y, v:z}
 * OR 
 * h, s, v
*/
function HSVtoRGB(h, s, v) {
    var r, g, b, i, f, p, q, t;
    if (arguments.length === 1) {
        s = h.s, v = h.v, h = h.h;
    }
    i = Math.floor(h * 6);
    f = h * 6 - i;
    p = v * (1 - s);
    q = v * (1 - f * s);
    t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}

/* accepts parameters
 * r  Object = {r:x, g:y, b:z}
 * OR 
 * r, g, b
*/
function RGBtoHSV(r, g, b) {
    if (arguments.length === 1) {
        g = r.g, b = r.b, r = r.r;
    }
    var max = Math.max(r, g, b), min = Math.min(r, g, b),
        d = max - min,
        h,
        s = (max === 0 ? 0 : d / max),
        v = max / 255;

    switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
    }

    return {
        h: h,
        s: s,
        v: v
    };
}

// source : https://gist.github.com/mjackson/5311256
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  l       The lightness
 * @return  Array           The RGB representation
 */
function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;

    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  return [ r * 255, g * 255, b * 255 ];
}

/**
 * From: http://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion
 *
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * @param   {number}  r       The red color value
 * @param   {number}  g       The green color value
 * @param   {number}  b       The blue color value
 * @return  {Array}           The HSL representation
 */
function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min){
        h = s = 0; // achromatic
    }else{
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max){
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}
</script>

<script>
/*
TODO:
- untangle local & external resource use in font manager (still more to do here)
*/

function FontManager(useExternalResources) {

if (useExternalResources === undefined || useExternalResources === null) {
  useExternalResources = false;
}

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
  return fontExtension;
}

// place to store font data that is part of the local game data
var localResources = {};

// place to store font data fetched from a server (only used in editor)
var externalResources = null;
if (useExternalResources) {
  externalResources = new ResourceLoader();// NOTE : this class doesn't exist in exported game
}

this.LoadResources = function(filenames, onLoadAll) {
  if (!useExternalResources)
    return;

  // TODO : is this being called too many times?
  var onLoad = function() {
    var count = externalResources.getResourceLoadedCount();

    if (count >= filenames.length && onLoadAll != null) {
      onLoadAll();
    }
  }

  for (var i = 0; i < filenames.length; i++) {
    externalResources.load("bitsyfont", filenames[i], onLoad);
  }
}

// manually add resource
this.AddResource = function(filename, fontdata) {
  if (useExternalResources) {
    externalResources.set(filename, fontdata);
  }
  else {
    localResources[filename] = fontdata;
  }
}

this.ContainsResource = function(filename) {
  if (useExternalResources) {
    return externalResources.contains(filename);
  }
  else {
    return localResources[filename] != null;
  }
}

function GetData(fontName) {
  if (useExternalResources) {
    return externalResources.get(fontName + fontExtension);
  }
  else {
    return localResources[fontName + fontExtension];
  }
}
this.GetData = GetData;

function Create(fontData) {
  return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
  var fontData = self.GetData(fontName);
  return self.Create(fontData);
}

function Font(fontData) {
  var name = "unknown";
  var width = 6; // default size so if you have NO font or an invalid font it displays boxes
  var height = 8;
  var chardata = {};
  var invalidCharData = {};

  this.getName = function() {
    return name;
  }

  this.getData = function() {
    return chardata;
  }

  this.getWidth = function() {
    return width;
  }

  this.getHeight = function() {
    return height;
  }

  this.hasChar = function(char) {
    var codepoint = char.charCodeAt(0);
    return chardata[codepoint] != null;
  }

  this.getChar = function(char) {

    var codepoint = char.charCodeAt(0);

    if (chardata[codepoint] != null) {
      return chardata[codepoint];
    }
    else {
      return invalidCharData;
    }
  }

  this.allCharCodes = function() {
    var codeList = [];
    for (var code in chardata) {
      codeList.push(code);
    }
    return codeList;
  }

  function parseFont(fontData) {
    if (fontData == null)
      return;

    var lines = fontData.split("\n");

    var isReadingChar = false;
    var isReadingCharProperties = false;
    var curCharLineCount = 0;
    var curCharCode = 0;

    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];

      if (line[0] === "#") {
        continue; // skip comment lines
      }

      if (!isReadingChar) {
        // READING NON CHARACTER DATA LINE
        var args = line.split(" ");
        if (args[0] == "FONT") {
          name = args[1];
        }
        else if (args[0] == "SIZE") {
          width = parseInt(args[1]);
          height = parseInt(args[2]);
        }
        else if (args[0] == "CHAR") {
          isReadingChar = true;
          isReadingCharProperties = true;

          curCharLineCount = 0;
          curCharCode = parseInt(args[1]);
          chardata[curCharCode] = { 
            width: width,
            height: height,
            offset: {
              x: 0,
              y: 0
            },
            spacing: width,
            data: []
          };
        }
      }
      else {
        // CHAR PROPERTIES
        if (isReadingCharProperties) {
          var args = line.split(" ");
          if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
            if (args[0] == "CHAR_SIZE") {
              // Custom character size - overrides the default character size for the font
              chardata[curCharCode].width = parseInt(args[1]);
              chardata[curCharCode].height = parseInt(args[2]);
              chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
            }
            else if (args[0] == "CHAR_OFFSET") {
              // Character offset - shift the origin of the character on the X or Y axis
              chardata[curCharCode].offset.x = parseInt(args[1]);
              chardata[curCharCode].offset.y = parseInt(args[2]);
            }
            else if (args[0] == "CHAR_SPACING") {
              // Character spacing:
              // specify total horizontal space taken up by the character
              // lets chars take up more or less space on a line than its bitmap does
              chardata[curCharCode].spacing = parseInt(args[1]);
            }
          }
          else {
            isReadingCharProperties = false;
          }
        }

        // CHAR DATA
        if (!isReadingCharProperties) {
          // READING CHARACTER DATA LINE
          for (var j = 0; j < chardata[curCharCode].width; j++)
          {
            chardata[curCharCode].data.push( parseInt(line[j]) );
          }

          curCharLineCount++;
          if (curCharLineCount >= height) {
            isReadingChar = false;
          }
        }
      }
    }

    // init invalid character box
    invalidCharData = { 
      width: width,
      height: height,
      offset: {
        x: 0,
        y: 0
      },
      spacing: width, // TODO : name?
      data: []
    };
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        if (x < width-1 && y < height-1) {
          invalidCharData.data.push(1);
        }
        else {
          invalidCharData.data.push(0);
        }
      }
    }
  }

  parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
  return new Interpreter();
};

this.CreateUtils = function() {
  return new Utils();
};

var Interpreter = function() {
  var env = new Environment();
  var parser = new Parser( env );

  this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

  // TODO -- maybe this should return a string instead othe actual script??
  this.Compile = function(scriptName, scriptStr) {
    // console.log("COMPILE");
    var script = parser.Parse( scriptStr );
    env.SetScript( scriptName, script );
  }
  this.Run = function(scriptName, exitHandler) { // Runs pre-compiled script
    // console.log("RUN");
    env.GetScript( scriptName )
      .Eval( env, function() { if(exitHandler!=null) exitHandler(); } );

    // console.log("SERIALIZE!!!!");
    // console.log( env.GetScript( scriptName ).Serialize() );
  }
  this.Interpret = function(scriptStr, exitHandler) { // Compiles and runs code immediately
    // console.log("INTERPRET");
    var script = parser.Parse( scriptStr );
    script.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );
  }
  this.HasScript = function(name) { return env.HasScript(name); };

  this.ResetEnvironment = function() {
    env = new Environment();
    parser = new Parser( env );
  }

  // TODO : move to utils?
  // for reading in dialog from the larger file format
  this.ReadDialogScript = function(lines, i) {
    return parser.ReadDialogScript(lines,i);
  }

  this.Parse = function(scriptStr) { // parses a script but doesn't save it
    return parser.Parse( scriptStr );
  }
  this.Eval = function(scripTree, exitHandler) { // runs a script stored externally
    scripTree.Eval( env, function() { if(exitHandler!=null) exitHandler(); } );
  }

  this.CreateExpression = function(expStr) {
    return parser.CreateExpression( expStr );
  }

  this.SetVariable = function(name,value,useHandler) {
    env.SetVariable(name,value,useHandler);
  }

  this.DeleteVariable = function(name,useHandler) {
    env.DeleteVariable(name,useHandler);
  }
  this.HasVariable = function(name) {
    return env.HasVariable(name);
  }

  this.SetOnVariableChangeHandler = function(onVariableChange) {
    env.SetOnVariableChangeHandler(onVariableChange);
  }
  this.GetVariableNames = function() {
    return env.GetVariableNames();
  }
  this.GetVariable = function(name) {
    return env.GetVariable(name);
  }
}


var Utils = function() {
  // for editor ui
  this.CreateDialogBlock = function(children,doIndentFirstLine) {
    if(doIndentFirstLine === undefined) doIndentFirstLine = true;
    var block = new BlockNode( BlockMode.Dialog, doIndentFirstLine );
    for(var i = 0; i < children.length; i++) {
      block.AddChild( children[i] );
    }
    return block;
  }

  this.ChangeSequenceType = function(oldSequence,type) {
    if(type === "sequence") {
      return new SequenceNode( oldSequence.options );
    }
    else if(type === "cycle") {
      return new CycleNode( oldSequence.options );
    }
    else if(type === "shuffle") {
      return new ShuffleNode( oldSequence.options );
    }
    return oldSequence;
  }

  this.CreateSequenceBlock = function() {
    var option1 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
    var option2 = new BlockNode( BlockMode.Dialog, false /*doIndentFirstLine*/ );
    var sequence = new SequenceNode( [ option1, option2 ] );
    var block = new BlockNode( BlockMode.Code );
    block.AddChild( sequence );
    return block;
  }

  this.CreateIfBlock = function() {
    var leftNode = new BlockNode( BlockMode.Code );
    leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
    var rightNode = new LiteralNode( 1 );
    var condition1 = new ExpNode("==", leftNode, rightNode );

    var condition2 = new ElseNode();

    var result1 = new BlockNode( BlockMode.Dialog );
    var result2 = new BlockNode( BlockMode.Dialog );

    var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
    var block = new BlockNode( BlockMode.Code );
    block.AddChild( ifNode );
    return block;
  }
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
  console.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
  onReturn(null);
}

function printFunc(environment,parameters,onReturn) {
  // console.log("PRINT FUNC");
  // console.log(parameters);
  if( parameters[0] != undefined && parameters[0] != null ) {
    // console.log(parameters[0]);
    // console.log(parameters[0].toString());
    // var textStr = parameters[0].toString();
    var textStr = "" + parameters[0];
    // console.log(textStr);
    var onFinishHandler = function() {
      // console.log("FINISHED PRINTING ---- SCRIPT");
      onReturn(null);
    }; // called when dialog is finished printing
    environment.GetDialogBuffer().AddText( textStr, onFinishHandler );
  }
  else {
    onReturn(null);
  }
}

function linebreakFunc(environment,parameters,onReturn) {
  // console.log("LINEBREAK FUNC");
  environment.GetDialogBuffer().AddLinebreak();
  onReturn(null);
}

function printDrawingFunc(environment,parameters,onReturn) {
  var drawingId = parameters[0];
  environment.GetDialogBuffer().AddDrawing( drawingId, function() {
    onReturn(null);
  });
}

function printSpriteFunc(environment,parameters,onReturn) {
  var spriteId = parameters[0];
  if(names.sprite.has(spriteId)) spriteId = names.sprite.get(spriteId); // id is actually a name
  var drawingId = sprite[spriteId].drw;
  printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
  var tileId = parameters[0];
  if(names.tile.has(tileId)) tileId = names.tile.get(tileId); // id is actually a name
  var drawingId = tile[tileId].drw;
  printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
  var itemId = parameters[0];
  if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
  var drawingId = item[itemId].drw;
  printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
  var allCharacters = "";
  var font = fontManager.Get( fontName );
  var codeList = font.allCharCodes();
  for (var i = 0; i < codeList.length; i++) {
    allCharacters += String.fromCharCode(codeList[i]) + " ";
  }
  printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
  var itemId = parameters[0];
  if(names.item.has(itemId)) itemId = names.item.get(itemId); // id is actually a name
  var itemCount = player().inventory[itemId] ? player().inventory[itemId] : 0; // TODO : ultimately the environment should include a reference to the game state
  // console.log("ITEM FUNC " + itemId + " " + itemCount);
  onReturn(itemCount);
}

function addOrRemoveTextEffect(environment,name) {
  if( environment.GetDialogBuffer().HasTextEffect(name) )
    environment.GetDialogBuffer().RemoveTextEffect(name);
  else
    environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
  addOrRemoveTextEffect(environment,"rbw");
  onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
  addOrRemoveTextEffect(environment,"clr1");
  onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
  addOrRemoveTextEffect(environment,"clr2");
  onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
  addOrRemoveTextEffect(environment,"clr3");
  onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
  addOrRemoveTextEffect(environment,"wvy");
  onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
  addOrRemoveTextEffect(environment,"shk");
  onReturn(null);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
  // console.log("SET " + left.name);

  if(left.type != "variable") {
    // not a variable! return null and hope for the best D:
    onReturn( null );
    return;
  }

  right.Eval(environment,function(rVal) {
    environment.SetVariable( left.name, rVal );
    // console.log("VAL " + environment.GetVariable( left.name ) );
    left.Eval(environment,function(lVal) {
      onReturn( lVal );
    });
  });
}
function equalExp(environment,left,right,onReturn) {
  // console.log("EVAL EQUAL");
  // console.log(left);
  // console.log(right);
  right.Eval(environment,function(rVal){
    left.Eval(environment,function(lVal){
      onReturn( lVal === rVal );
    });
  });
}
function greaterExp(environment,left,right,onReturn) {
  right.Eval(environment,function(rVal){
    left.Eval(environment,function(lVal){
      onReturn( lVal > rVal );
    });
  });
}
function lessExp(environment,left,right,onReturn) {
  right.Eval(environment,function(rVal){
    left.Eval(environment,function(lVal){
      onReturn( lVal < rVal );
    });
  });
}
function greaterEqExp(environment,left,right,onReturn) {
  right.Eval(environment,function(rVal){
    left.Eval(environment,function(lVal){
      onReturn( lVal >= rVal );
    });
  });
}
function lessEqExp(environment,left,right,onReturn) {
  right.Eval(environment,function(rVal){
    left.Eval(environment,function(lVal){
      onReturn( lVal <= rVal );
    });
  });
}
function multExp(environment,left,right,onReturn) {
  right.Eval(environment,function(rVal){
    left.Eval(environment,function(lVal){
      onReturn( lVal * rVal );
    });
  });
}
function divExp(environment,left,right,onReturn) {
  right.Eval(environment,function(rVal){
    left.Eval(environment,function(lVal){
      onReturn( lVal / rVal );
    });
  });
}
function addExp(environment,left,right,onReturn) {
  right.Eval(environment,function(rVal){
    left.Eval(environment,function(lVal){
      onReturn( lVal + rVal );
    });
  });
}
function subExp(environment,left,right,onReturn) {
  right.Eval(environment,function(rVal){
    left.Eval(environment,function(lVal){
      onReturn( lVal - rVal );
    });
  });
}

/* ENVIRONMENT */
var Environment = function() {
  var dialogBuffer = null;
  this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
  this.GetDialogBuffer = function() { return dialogBuffer; };

  var functionMap = new Map();
  functionMap.set("print", printFunc);
  functionMap.set("say", printFunc);
  functionMap.set("br", linebreakFunc);
  functionMap.set("item", itemFunc);
  functionMap.set("rbw", rainbowFunc);
  functionMap.set("clr1", color1Func);
  functionMap.set("clr2", color2Func);
  functionMap.set("clr3", color3Func);
  functionMap.set("wvy", wavyFunc);
  functionMap.set("shk", shakyFunc);
  functionMap.set("printSprite", printSpriteFunc);
  functionMap.set("printTile", printTileFunc);
  functionMap.set("printItem", printItemFunc);
  functionMap.set("debugOnlyPrintFont", printFontFunc); // DEBUG ONLY

  this.HasFunction = function(name) { return functionMap.has(name); };
  this.EvalFunction = function(name,parameters,onReturn) {
    // console.log(functionMap);
    // console.log(name);
    functionMap.get( name )( this, parameters, onReturn );
  }

  var variableMap = new Map();

  this.HasVariable = function(name) { return variableMap.has(name); };
  this.GetVariable = function(name) { return variableMap.get(name); };
  this.SetVariable = function(name,value,useHandler) {
    // console.log("SET VARIABLE " + name + " = " + value);
    if(useHandler === undefined) useHandler = true;
    variableMap.set(name, value);
    if(onVariableChangeHandler != null && useHandler)
      onVariableChangeHandler(name);
  };
  this.DeleteVariable = function(name,useHandler) {
    if(useHandler === undefined) useHandler = true;
    if(variableMap.has(name)) {
      variableMap.delete(name);
      if(onVariableChangeHandler != null && useHandler)
        onVariableChangeHandler(name);
    }
  };

  var operatorMap = new Map();
  operatorMap.set("=", setExp);
  operatorMap.set("==", equalExp);
  operatorMap.set(">", greaterExp);
  operatorMap.set("<", lessExp);
  operatorMap.set(">=", greaterEqExp);
  operatorMap.set("<=", lessEqExp);
  operatorMap.set("*", multExp);
  operatorMap.set("/", divExp);
  operatorMap.set("+", addExp);
  operatorMap.set("-", subExp);

  this.HasOperator = function(sym) { return operatorMap.get(sym); };
  this.EvalOperator = function(sym,left,right,onReturn) {
    operatorMap.get( sym )( this, left, right, onReturn );
  }

  var scriptMap = new Map();
  this.HasScript = function(name) { return scriptMap.has(name); };
  this.GetScript = function(name) { return scriptMap.get(name); };
  this.SetScript = function(name,script) { scriptMap.set(name, script); };

  var onVariableChangeHandler = null;
  this.SetOnVariableChangeHandler = function(onVariableChange) {
    onVariableChangeHandler = onVariableChange;
  }
  this.GetVariableNames = function() {
    return Array.from( variableMap.keys() );
  }
}

function leadingWhitespace(depth) {
  var str = "";
  for(var i = 0; i < depth; i++) {
    str += "  "; // two spaces per indent
  }
  // console.log("WHITESPACE " + depth + " ::" + str + "::");
  return str;
}

/* NODES */
var TreeRelationship = function() {
  this.parent = null;
  this.children = [];
  this.AddChild = function(node) {
    this.children.push( node );
    node.parent = this;
  };

  this.VisitAll = function(visitor) {
    visitor.Visit( this );
    for( var i = 0; i < this.children.length; i++ ) {
      this.children[i].VisitAll( visitor );
    }
  };
}

var BlockMode = {
  Code : "code",
  Dialog : "dialog"
};

var BlockNode = function(mode, doIndentFirstLine) {
  Object.assign( this, new TreeRelationship() );
  // Object.assign( this, new Runnable() );
  this.type = "block";
  this.mode = mode;

  this.Eval = function(environment,onReturn) {
    // console.log("EVAL BLOCK " + this.children.length);

    if( this.onEnter != null ) this.onEnter();

    var lastVal = null;
    var i = 0;
    function evalChildren(children,done) {
      if(i < children.length) {
        // console.log(">> CHILD " + i);
        children[i].Eval( environment, function(val) {
          // console.log("<< CHILD " + i);
          lastVal = val;
          i++;
          evalChildren(children,done);
        } );
      }
      else {
        done();
      }
    };
    var self = this;
    evalChildren( this.children, function() {
      if( self.onExit != null ) self.onExit();
      onReturn(lastVal);
    } );
  }

  if(doIndentFirstLine === undefined) doIndentFirstLine = true; // This is just for serialization

  this.Serialize = function(depth) {
    if(depth === undefined) depth = 0;

    // console.log("SERIALIZE BLOCK!!!");
    // console.log(depth);
    // console.log(doIndentFirstLine);

    var str = "";
    var lastNode = null;
    if (this.mode === BlockMode.Code) str += "{"; // todo: increase scope of Sym?
    for (var i = 0; i < this.children.length; i++) {

      var curNode = this.children[i];

      if(curNode.type === "block" && lastNode && lastNode.type === "block" && !isBlockWithNoNewline(curNode) && !isBlockWithNoNewline(lastNode))
        str += "\n";

      var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
      var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");
      if(this.mode === BlockMode.Dialog && (shouldIndentFirstLine || shouldIndentAfterLinebreak))
        str += leadingWhitespace(depth);
      str += curNode.Serialize(depth);
      lastNode = curNode;
    }
    if (this.mode === BlockMode.Code) str += "}";
    return str;
  }
}

function isBlockWithNoNewline(node) {
  return isTextEffectBlock(node) || isMultilineListBlock(node);
}

function isTextEffectBlock(node) {
  if(node.type === "block") {
    if(node.children.length > 0 && node.children[0].type === "function") {
      var func = node.children[0];
      if(func.name === "clr1" || func.name === "clr2" || func.name === "clr3" || func.name === "wvy" || func.name === "shk" || func.name === "rbw") {
        return true;
      }
    }
  }
  return false;
}

function isMultilineListBlock(node) {
  if(node.type === "block") {
    if(node.children.length > 0) {
      var child = node.children[0];
      if(child.type === "sequence" || child.type === "cycle" || child.type === "shuffle" || child.type === "if") {
        return true;
      }
    }
  }
  return false;
}

var FuncNode = function(name,arguments) {
  Object.assign( this, new TreeRelationship() );
  // Object.assign( this, new Runnable() );
  this.type = "function";
  this.name = name;
  this.arguments = arguments;

  this.Eval = function(environment,onReturn) {

    if( this.onEnter != null ) this.onEnter();

    // console.log("FUNC");
    // console.log(this.arguments);
    var argumentValues = [];
    var i = 0;
    function evalArgs(arguments,done) {
      if(i < arguments.length) {
        // Evaluate each argument
        arguments[i].Eval( environment, function(val) {
          argumentValues.push( val );
          i++;
          evalArgs(arguments,done);
        } );
      }
      else {
        done();
      }
    };
    var self = this; // hack to deal with scope
    evalArgs( this.arguments, function() {
      // Then evaluate the function
      // console.log("ARGS");
      // console.log(argumentValues);

      if( self.onExit != null ) self.onExit();

      environment.EvalFunction( self.name, argumentValues, onReturn );
    } );
  }

  this.Serialize = function(depth) {
    var isDialogBlock = this.parent.mode && this.parent.mode === BlockMode.Dialog;
    if(isDialogBlock && this.name === "print") {
      // TODO this could cause problems with "real" print functions
      return this.arguments[0].value; // first argument should be the text of the {print} func
    }
    else if(isDialogBlock && this.name === "br") {
      return "\n";
    }
    else {
      var str = "";
      str += this.name;
      for(var i = 0; i < this.arguments.length; i++) {
        str += " ";
        str += this.arguments[i].Serialize(depth);
      }
      return str;
    }
  }
}

var LiteralNode = function(value) {
  Object.assign( this, new TreeRelationship() );
  // Object.assign( this, new Runnable() );
  this.type = "literal";
  this.value = value;

  this.Eval = function(environment,onReturn) {
    onReturn(this.value);
  }

  this.Serialize = function(depth) {
    var str = "";

    if(this.value === null)
      return str;

    if(typeof this.value === "string") str += '"';
    str += this.value;
    if(typeof this.value === "string") str += '"';

    return str;
  }
}

var VarNode = function(name) {
  Object.assign( this, new TreeRelationship() );
  // Object.assign( this, new Runnable() );
  this.type = "variable";
  this.name = name;

  this.Eval = function(environment,onReturn) {
    // console.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
    if( environment.HasVariable(this.name) )
      onReturn( environment.GetVariable( this.name ) );
    else
      onReturn(null); // not a valid variable -- return null and hope that's ok
  } // TODO: might want to store nodes in the variableMap instead of values???

  this.Serialize = function(depth) {
    var str = "" + this.name;
    return str;
  }
}

var ExpNode = function(operator, left, right) {
  Object.assign( this, new TreeRelationship() );
  this.type = "operator";
  this.operator = operator;
  this.left = left;
  this.right = right;

  this.Eval = function(environment,onReturn) {
    // console.log("EVAL " + this.operator);
    var self = this; // hack to deal with scope
    environment.EvalOperator( this.operator, this.left, this.right, 
      function(val){
        // console.log("EVAL EXP " + self.operator + " " + val);
        onReturn(val);
      } );
    // NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
  }

  this.Serialize = function(depth) {
    var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

    if(!isNegativeNumber) {
      var str = "";
      str += this.left.Serialize(depth);
      str += " " + this.operator + " ";
      str += this.right.Serialize(depth);
      return str;
    }
    else {
      return this.operator + this.right.Serialize(depth); // hacky but seems to work
    }
  }

  this.VisitAll = function(visitor) {
    visitor.Visit( this );
    if(this.left != null)
      this.left.VisitAll( visitor );
    if(this.right != null)
      this.right.VisitAll( visitor );
  };
}

var SequenceBase = function() {
  this.Serialize = function(depth) {
    var str = "";
    str += this.type + "\n";
    for (var i = 0; i < this.options.length; i++) {
      // console.log("SERIALIZE SEQUENCE ");
      // console.log(depth);
      str += leadingWhitespace(depth + 1) + Sym.List + " " + this.options[i].Serialize(depth + 2) + "\n";
    }
    str += leadingWhitespace(depth);
    return str;
  }

  this.VisitAll = function(visitor) {
    visitor.Visit( this );
    for( var i = 0; i < this.options.length; i++ ) {
      this.options[i].VisitAll( visitor );
    }
  };
}

var SequenceNode = function(options) {
  Object.assign( this, new TreeRelationship() );
  Object.assign( this, new SequenceBase() );
  this.type = "sequence";
  this.options = options;

  var index = 0;
  this.Eval = function(environment,onReturn) {
    // console.log("SEQUENCE " + index);
    this.options[index].Eval( environment, onReturn );

    var next = index + 1;
    if(next < this.options.length)
      index = next;
  }
}

var CycleNode = function(options) {
  Object.assign( this, new TreeRelationship() );
  Object.assign( this, new SequenceBase() );
  this.type = "cycle";
  this.options = options;

  var index = 0;
  this.Eval = function(environment,onReturn) {
    // console.log("CYCLE " + index);
    this.options[index].Eval( environment, onReturn );

    var next = index + 1;
    if(next < this.options.length)
      index = next;
    else
      index = 0;
  }
}

var ShuffleNode = function(options) {
  Object.assign( this, new TreeRelationship() );
  Object.assign( this, new SequenceBase() );
  this.type = "shuffle";
  this.options = options;

  var optionsShuffled = [];
  function shuffle(options) {
    optionsShuffled = [];
    var optionsUnshuffled = options.slice();
    while(optionsUnshuffled.length > 0) {
      var i = Math.floor( Math.random() * optionsUnshuffled.length );
      optionsShuffled.push( optionsUnshuffled.splice(i,1)[0] );
    }
  }
  shuffle(this.options);

  var index = 0;
  this.Eval = function(environment,onReturn) {
    // OLD RANDOM VERSION
    // var index = Math.floor(Math.random() * this.options.length);
    // this.options[index].Eval( environment, onReturn );

    optionsShuffled[index].Eval( environment, onReturn );
    
    index++;
    if (index >= this.options.length) {
      shuffle(this.options);
      index = 0;
    }
  }
}

var IfNode = function(conditions, results, isSingleLine) {
  Object.assign( this, new TreeRelationship() );
  this.type = "if";
  this.conditions = conditions;
  this.results = results;

  this.Eval = function(environment,onReturn) {
    // console.log("EVAL IF");
    var i = 0;
    var self = this;
    function TestCondition() {
      // console.log("EVAL " + i);
      self.conditions[i].Eval(environment, function(val) {
        // console.log(val);
        if(val == true) {
          self.results[i].Eval(environment, onReturn);
        }
        else if(i+1 < self.conditions.length) {
          i++;
          TestCondition(); // test next condition
        }
        else {
          onReturn(null); // out of conditions and none were true
        }
      });
    };
    TestCondition();
  }

  if(isSingleLine === undefined) isSingleLine = false; // This is just for serialization

  this.Serialize = function(depth) {
    var str = "";
    if(isSingleLine) {
      str += this.conditions[0].Serialize() + " ? " + this.results[0].Serialize();
      if(this.conditions.length > 1 && this.conditions[1].type === "else")
        str += " : " + this.results[1].Serialize();
    }
    else {
      str += "\n";
      for (var i = 0; i < this.conditions.length; i++) {
        str += leadingWhitespace(depth + 1) + Sym.List + " " + this.conditions[i].Serialize(depth) + " ?\n";
        str += this.results[i].Serialize(depth + 2) + "\n";
      }
      str += leadingWhitespace(depth);
    }
    return str;
  }

  this.IsSingleLine = function() {
    return isSingleLine;
  }

  this.VisitAll = function(visitor) {
    visitor.Visit( this );
    for( var i = 0; i < this.conditions.length; i++ ) {
      this.conditions[i].VisitAll( visitor );
    }
    for( var i = 0; i < this.results.length; i++ ) {
      this.results[i].VisitAll( visitor );
    }
  };
}

var ElseNode = function() {
  Object.assign( this, new TreeRelationship() );
  this.type = "else";

  this.Eval = function(environment,onReturn) {
    onReturn(true);
  }

  this.Serialize = function() {
    return "else";
  }
}

var Sym = {
  // DialogOpen : "/\"",
  // DialogClose : "\"/",
  DialogOpen : '"""',
  DialogClose : '"""',
  CodeOpen : "{",
  CodeClose : "}",
  Linebreak : "\n", // just call it "break" ?
  Separator : ":",
  List : "-",
  String : '"'
};

var Parser = function(env) {
  var environment = env;

  this.Parse = function(scriptStr) {
    // console.log("NEW PARSE!!!!!!");

    // TODO : make this work for single-line, no dialog block scripts

    var state = new ParserState( new BlockNode(BlockMode.Dialog), scriptStr );

    if( state.MatchAhead(Sym.DialogOpen) ) {
      // multi-line dialog block
      var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );
      state = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
      state = ParseDialog( state );
    }
    // else if( state.MatchAhead(Sym.CodeOpen) ) { // NOTE: This causes problems when you lead with a code block
    //  // code-block: should this ever happen?
    //  state = ParseCodeBlock( state );
    // }
    else {
      // single-line dialog block
      state = ParseDialog( state );
    }

    // console.log( state.rootNode );
    return state.rootNode;
  };

  this.ReadDialogScript = function(lines, i) {
    var scriptStr = "";
    if (lines[i] === Sym.DialogOpen) {
      scriptStr += lines[i] + "\n";
      i++;
      while(lines[i] != Sym.DialogClose) {
        scriptStr += lines[i] + "\n";
        i++;
      }
      scriptStr += lines[i];
      i++;
    }
    else {
      scriptStr += lines[i];
    }
    return { script:scriptStr, index:i };
  }

  var ParserState = function( rootNode, str ) {
    this.rootNode = rootNode;
    this.curNode = this.rootNode;

    var sourceStr = str;
    var i = 0;
    this.Index = function() { return i; };
    this.Count = function() { return sourceStr.length; };
    this.Done = function() { return i >= sourceStr.length; };
    this.Char = function() { return sourceStr[i]; };
    this.Step = function(n) { if(n===undefined) n=1; i += n; };
    this.MatchAhead = function(str) {
      // console.log(str);
      str = "" + str; // hack to turn single chars into strings
      // console.log(str);
      // console.log(str.length);
      for(var j = 0; j < str.length; j++) {
        if( i + j >= sourceStr.length )
          return false;
        else if( str[j] != sourceStr[i+j] )
          return false;
      }
      return true;
    }
    this.Peak = function(end) {
      var str = "";
      var j = i;
      // console.log(j);
      while(j < sourceStr.length && end.indexOf( sourceStr[j] ) == -1 ) {
        str += sourceStr[j];
        j++;
      }
      // console.log("PEAK ::" + str + "::");
      return str;
    }
    this.ConsumeBlock = function( open, close ) {
      var startIndex = i;

      var matchCount = 0;
      if( this.MatchAhead( open ) ) {
        matchCount++;
        this.Step( open.length );
      }

      while( matchCount > 0 && !this.Done() ) {
        if( this.MatchAhead( close ) ) {
          matchCount--;
          this.Step( close.length );
        }
        else if( this.MatchAhead( open ) ) {
          matchCount++;
          this.Step( open.length );
        }
        else {
          this.Step();
        }
      }

      // console.log("!!! " + startIndex + " " + i);

      return sourceStr.slice( startIndex + open.length, i - close.length );
    }
    this.Print = function() { /*console.log(sourceStr);*/ };
  };

  function ParseDialog(state) {
    // console.log("PARSE DIALOG");
    state.Print();

    // for linebreak logic: add linebreaks after lines with dialog or empty lines (if it's not the very first line)
    var hasBlock = false;
    var hasDialog = false;
    var isFirstLine = true;

    // console.log("---- PARSE DIALOG ----");

    var text = "";
    var addTextNode = function() {
      // console.log("TEXT " + text.length);
      if (text.length > 0) {
        // console.log("TEXT " + text);
        // console.log("text!!");
        // console.log([text]);

        state.curNode.AddChild( new FuncNode( "print", [new LiteralNode(text)] ) );
        text = "";

        hasDialog = true;
      }
    }

    while ( !state.Done() ) {

      if( state.MatchAhead(Sym.CodeOpen) ) {
        addTextNode();
        state = ParseCodeBlock( state );

        // console.log("CODE");

        var len = state.curNode.children.length;
        if(len > 0 && state.curNode.children[len-1].type === "block") {
          var block = state.curNode.children[len-1];
          if(isMultilineListBlock(block))
            hasDialog = true; // hack to get correct newline behavior for multiline blocks
        }

        hasBlock = true;
      }
      // NOTE: nested dialog blocks disabled for now
      // else if( state.MatchAhead(Sym.DialogOpen) ) {
      //  addTextNode();
      //  state = ParseDialogBlock( state ); // These can be nested (should they though???)

      //  hasBlock = true;
      // }
      else {
        if ( state.MatchAhead(Sym.Linebreak) ) {
          addTextNode();

          /*
          NOTES:
          linebreaks SHOULD happen on
          - lines with text (including the first or last line)
          - empty lines (that are NOT the first or last line)
          linebreaks should NOT happen on
          - lines with only CODE blocks
          - empty FIRST or LAST lines

          also, apparently:
          - NEVER line break on the last line
          */
          var isLastLine = (state.Index() + 1) == state.Count();
          // console.log("block " + hasBlock);
          // console.log("dialog " + hasDialog);
          var isEmptyLine = !hasBlock && !hasDialog;
          // console.log("empty " + isEmptyLine);
          var isValidEmptyLine = isEmptyLine && !(isFirstLine || isLastLine);
          // console.log("valid empty " + isValidEmptyLine);
          var shouldAddLinebreak = (hasDialog || isValidEmptyLine) && !isLastLine; // last clause is a hack (but it works - why?)
          // console.log("LINEBREAK? " + shouldAddLinebreak);
          if( shouldAddLinebreak ) {
            // console.log("NEWLINE");
            // console.log("empty? " + isEmptyLine);
            // console.log("dialog? " + hasDialog);
            state.curNode.AddChild( new FuncNode( "br", [] ) ); // use function or character?
          }

          // linebreak logic
          isFirstLine = false;
          hasBlock = false;
          hasDialog = false;

          text = "";
        }
        else {
          text += state.Char();
        }
        state.Step();
      }

    }
    addTextNode();

    // console.log("---- PARSE DIALOG ----");

    // console.log(state);
    return state;
  }

  function ParseDialogBlock(state) {
    var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

    var dialogState = new ParserState( new BlockNode(BlockMode.Dialog), dialogStr );
    dialogState = ParseDialog( dialogState );

    state.curNode.AddChild( dialogState.rootNode );

    return state;
  }

  function ParseIf(state) {
    var conditionStrings = [];
    var resultStrings = [];
    var curIndex = -1;
    var isNewline = true;
    var isConditionDone = false;
    var codeBlockCount = 0;

    while( !state.Done() ) {
      if(state.Char() === Sym.CodeOpen)
        codeBlockCount++;
      else if(state.Char() === Sym.CodeClose)
        codeBlockCount--;

      var isWhitespace = (state.Char() === " " || state.Char() === "\t");
      var isSkippableWhitespace = isNewline && isWhitespace;
      var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

      if(isNewListItem) {
        curIndex++;
        isConditionDone = false;
        conditionStrings[curIndex] = "";
        resultStrings[curIndex] = "";
      }
      else if(curIndex > -1) {
        if(!isConditionDone) {
          if(state.Char() === "?" || state.Char() === "\n") { // TODO: use Sym
            // end of condition
            isConditionDone = true;
          }
          else {
            // read in condition
            conditionStrings[curIndex] += state.Char();
          }
        }
        else {
          // read in result
          if(!isSkippableWhitespace)
            resultStrings[curIndex] += state.Char();
        }
      }

      isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

      state.Step();
    }

    // console.log("PARSE IF:");
    // console.log(conditionStrings);
    // console.log(resultStrings);

    var conditions = [];
    for(var i = 0; i < conditionStrings.length; i++) {
      var str = conditionStrings[i].trim();
      if(str === "else") {
        conditions.push( new ElseNode() );
      }
      else {
        var exp = CreateExpression( str );
        conditions.push( exp );
      }
    }

    var results = [];
    for(var i = 0; i < resultStrings.length; i++) {
      var str = resultStrings[i];
      var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
      dialogBlockState = ParseDialog( dialogBlockState );
      var dialogBlock = dialogBlockState.rootNode;
      results.push( dialogBlock );
    }

    state.curNode.AddChild( new IfNode( conditions, results ) );

    return state;
  }

  function IsSequence(str) {
    // console.log("IsSequence? " + str);
    return str === "sequence" || str === "cycle" || str === "shuffle";
  }

  // TODO: don't forget about eating whitespace
  function ParseSequence(state, sequenceType) {
    // console.log("SEQUENCE " + sequenceType);
    state.Print();

    var isNewline = false;
    var itemStrings = [];
    var curItemIndex = -1; // -1 indicates not reading an item yet
    var codeBlockCount = 0;

    while( !state.Done() ) {
      if(state.Char() === Sym.CodeOpen)
        codeBlockCount++;
      else if(state.Char() === Sym.CodeClose)
        codeBlockCount--;

      var isWhitespace = (state.Char() === " " || state.Char() === "\t");
      var isSkippableWhitespace = isNewline && isWhitespace;
      var isNewListItem = isNewline && (codeBlockCount <= 0) && (state.Char() === Sym.List);

      if(isNewListItem) {
        // console.log("found next list item");
        curItemIndex++;
        itemStrings[curItemIndex] = "";
      }
      else if(curItemIndex > -1) {
        if(!isSkippableWhitespace)
          itemStrings[curItemIndex] += state.Char();
      }

      isNewline = (state.Char() === Sym.Linebreak) || isSkippableWhitespace || isNewListItem;

      // console.log(state.Char());
      state.Step();
    }
    // console.log(itemStrings);
    // console.log("SEQUENCE DONE");

    var options = [];
    for(var i = 0; i < itemStrings.length; i++) {
      var str = itemStrings[i];
      var dialogBlockState = new ParserState( new BlockNode( BlockMode.Dialog, false /* doIndentFirstLine */ ), str );
      dialogBlockState = ParseDialog( dialogBlockState );
      var dialogBlock = dialogBlockState.rootNode;
      options.push( dialogBlock );
    }

    // console.log(options);

    if(sequenceType === "sequence")
      state.curNode.AddChild( new SequenceNode( options ) );
    else if(sequenceType === "cycle")
      state.curNode.AddChild( new CycleNode( options ) );
    else if(sequenceType === "shuffle")
      state.curNode.AddChild( new ShuffleNode( options ) );

    return state;
  }

  function ParseFunction(state, funcName) {
    var args = [];

    var curSymbol = "";
    function OnSymbolEnd() {
      curSymbol = curSymbol.trim();
      // console.log("PARAMTER " + curSymbol);
      args.push( StringToValue(curSymbol) );
      // console.log(args);
      curSymbol = "";
    }

    while( !( state.Char() === "\n" || state.Done() ) ) {
      if( state.MatchAhead(Sym.CodeOpen) ) {
        var codeBlockState = new ParserState( new BlockNode(BlockMode.Code), state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose ) );
        codeBlockState = ParseCode( codeBlockState );
        var codeBlock = codeBlockState.rootNode;
        args.push( codeBlock );
        curSymbol = "";
      }
      else if( state.MatchAhead(Sym.String) ) {
        /* STRING LITERAL */
        var str = state.ConsumeBlock(Sym.String, Sym.String);
        // console.log("STRING " + str);
        args.push( new LiteralNode(str) );
        curSymbol = "";
      }
      else if(state.Char() === " " && curSymbol.length > 0) {
        OnSymbolEnd();
      }
      else {
        curSymbol += state.Char();
      }
      state.Step();
    }

    if(curSymbol.length > 0) {
      OnSymbolEnd();
    }

    state.curNode.AddChild( new FuncNode( funcName, args ) );

    return state;
  }

  function IsValidVariableName(str) {
    var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
    var isValid = reg.test(str);
    // console.log("VALID variable??? " + isValid);
    return isValid;
  }

  function StringToValue(valStr) {
    if(valStr[0] === Sym.CodeOpen) {
      // CODE BLOCK!!!
      var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
      var codeBlockState = new ParserState( new BlockNode( BlockMode.Code ), codeStr );
      codeBlockState = ParseCode( codeBlockState );
      return codeBlockState.rootNode;
    }
    else if(valStr[0] === Sym.String) {
      // STRING!!
      // console.log("STRING");
      var str = "";
      var i = 1;
      while (i < valStr.length && valStr[i] != Sym.String) {
        str += valStr[i];
        i++;
      }
      // console.log(str);
      return new LiteralNode( str );
    }
    else if(valStr === "true") {
      // BOOL
      return new LiteralNode( true );
    }
    else if(valStr === "false") {
      // BOOL
      return new LiteralNode( false );
    }
    else if( !isNaN(parseFloat(valStr)) ) {
      // NUMBER!!
      // console.log("NUMBER!!! " + valStr);
      return new LiteralNode( parseFloat(valStr) );
    }
    else if(IsValidVariableName(valStr)) {
      // VARIABLE!!
      // console.log("VARIABLE");
      return new VarNode(valStr); // TODO : check for valid potential variables
    }
    else {
      // uh oh
      return new LiteralNode(null);
    }
  }

  var setSymbol = "=";
  var ifSymbol = "?";
  var elseSymbol = ":";
  // var operatorSymbols = ["==", ">", "<", ">=", "<=", "*", "/", "+", "-"];
  var operatorSymbols = ["-", "+", "/", "*", "<=", ">=", "<", ">", "=="]; // operators need to be in reverse order
  function CreateExpression(expStr) {
    expStr = expStr.trim();

    function IsInsideString(index) {
      var inString = false;
      for(var i = 0; i < expStr.length; i++) {
        if(expStr[i] === Sym.String)
          inString = !inString;

        if(index === i)
          return inString;
      }
      return false;
    }

    function IsInsideCode(index) {
      var count = 0;
      for(var i = 0; i < expStr.length; i++) {
        if(expStr[i] === Sym.CodeOpen)
          count++;
        else if(expStr[i] === Sym.CodeClose)
          count--;

        if(index === i)
          return count > 0;
      }
      return false;
    }
  
    var operator = null;

    // set is special because other operator can look like it, and it has to go first in the order of operations
    var setIndex = expStr.indexOf(setSymbol);
    if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
      if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
        // ok it actually IS a set operator and not ==, >=, or <=
        operator = setSymbol;
        var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
        var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
        var right = CreateExpression( expStr.substring(setIndex+setSymbol.length) );
        var exp = new ExpNode( operator, left, right );
        return exp;
      }
    }

    // special if "expression" for single-line if statements
    var ifIndex = expStr.indexOf(ifSymbol);
    if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
      operator = ifSymbol;
      var conditionStr = expStr.substring(0,ifIndex).trim();
      var conditions = [ CreateExpression(conditionStr) ];

      var resultStr = expStr.substring(ifIndex+ifSymbol.length);
      var results = [];
      function AddResult(str) {
        var dialogBlockState = new ParserState( new BlockNode(BlockMode.Dialog), str );
        dialogBlockState = ParseDialog( dialogBlockState );
        var dialogBlock = dialogBlockState.rootNode;
        results.push( dialogBlock );
      }

      var elseIndex = resultStr.indexOf(elseSymbol); // does this need to test for strings?
      if(elseIndex > -1) {
        conditions.push( new ElseNode() );

        var elseStr = resultStr.substring(elseIndex+elseSymbol.length);
        var resultStr = resultStr.substring(0,elseIndex);

        AddResult( resultStr.trim() );
        AddResult( elseStr.trim() );
      }
      else {
        AddResult( resultStr.trim() );
      }

      return new IfNode( conditions, results, true /*isSingleLine*/ );
    }

    for( var i = 0; (operator == null) && (i < operatorSymbols.length); i++ ) {
      var opSym = operatorSymbols[i];
      var opIndex = expStr.indexOf( opSym );
      if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
        operator = opSym;
        var left = CreateExpression( expStr.substring(0,opIndex) );
        var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
        var exp = new ExpNode( operator, left, right );
        return exp;
      }
    }

    if( operator == null ) {
      return StringToValue(expStr);
    }
  }
  this.CreateExpression = CreateExpression;

  function ParseExpression(state) {
    var line = state.Peak( [Sym.Linebreak] );
    // console.log("EXPRESSION " + line);
    var exp = CreateExpression( line );
    // console.log(exp);
    state.curNode.AddChild( exp );
    state.Step( line.length );
    return state;
  }

  function ParseCode(state) {
    // TODO : how do I do this parsing??? one expression per block? or per line?
    while ( !state.Done() ) {

      if( state.Char() === " " || state.Char() === "\t" || state.Char() === "\n" ) { // TODO: symbols? IsWhitespace func?
        state.Step(); // consume whitespace
      }
      else if( state.MatchAhead(Sym.CodeOpen) ) {
        state = ParseCodeBlock( state );
      }
      // NOTE: nested dialog blocks disabled for now
      // else if( state.MatchAhead(Sym.DialogOpen) ) {
      //  state = ParseDialogBlock( state ); // These can be nested (should they though???)
      // }
      else if( state.Char() === Sym.List && (state.Peak([]).indexOf("?") > -1) ) { // TODO : symbols? matchahead?
        // console.log("PEAK IF " + state.Peak( ["?"] ));
        state = ParseIf( state );
      }
      else if( environment.HasFunction( state.Peak( [" "] ) ) ) { // TODO --- what about newlines???
        var funcName = state.Peak( [" "] );
        state.Step( funcName.length );
        state = ParseFunction( state, funcName );
      }
      else if( IsSequence( state.Peak( [" ", Sym.Linebreak] ) ) ) {
        var sequenceType = state.Peak( [" ", Sym.Linebreak] );
        state.Step( sequenceType.length );
        state = ParseSequence( state, sequenceType );
      }
      else {
        state = ParseExpression( state );
      }
    }

    return state;
  }

  function ParseCodeBlock(state) {
    var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );

    // console.log("PARSE CODE");
    // console.log(codeStr);

    var codeState = new ParserState( new BlockNode(BlockMode.Code), codeStr );
    codeState = ParseCode( codeState );
    
    state.curNode.AddChild( codeState.rootNode );

    return state;
  }

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
  return new DialogRenderer();
};

this.CreateBuffer = function() {
  return new DialogBuffer();
};

var DialogRenderer = function() {

  // TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
  var textboxInfo = {
    img : null,
    width : 104,
    height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
    top : 12,
    left : 12,
    bottom : 12, //for drawing it from the bottom
    font_scale : 0.5, // we draw font at half-size compared to everything else
    padding_vert : 2,
    padding_horz : 4,
    arrow_height : 5,
  };

  var font = null;
  this.SetFont = function(f) {
    font = f;
    textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;
    textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);
  }

  function textScale() {
    return scale * textboxInfo.font_scale;
  }

  function relativeFontWidth() {
    return Math.ceil( font.getWidth() * textboxInfo.font_scale );
  }

  function relativeFontHeight() {
    return Math.ceil( font.getHeight() * textboxInfo.font_scale );
  }

  var context = null;
  this.AttachContext = function(c) {
    context = c;
  };

  this.ClearTextbox = function() {
    if(context == null) return;

    //create new image none exists
    if(textboxInfo.img == null)
      textboxInfo.img = context.createImageData(textboxInfo.width*scale, textboxInfo.height*scale);

    // fill text box with black
    for (var i=0;i<textboxInfo.img.data.length;i+=4)
    {
      textboxInfo.img.data[i+0]=255;
      textboxInfo.img.data[i+1]=253;
      textboxInfo.img.data[i+2]=232;
      textboxInfo.img.data[i+3]=255;
    }
  };

  var isCentered = false;
  this.SetCentered = function(centered) {
    isCentered = centered;
  };

  this.DrawTextbox = function() {
    if(context == null) return;
    if (isCentered) {
      context.putImageData(textboxInfo.img, textboxInfo.left*scale, ((height/2)-(textboxInfo.height/2))*scale);
    }
    else if (player().y < mapsize/2) {
      //bottom
      context.putImageData(textboxInfo.img, textboxInfo.left*scale, (height-textboxInfo.bottom-textboxInfo.height)*scale);
    }
    else {
      //top
      context.putImageData(textboxInfo.img, textboxInfo.left*scale, textboxInfo.top*scale);
    }
  };

  var arrowdata = [
    0,0,0,0,0,
    1,0,1,0,1,
    0,0,0,0,0
  ];
  this.DrawNextArrow = function() {
    // console.log("draw arrow!");
    var top = (textboxInfo.height-5) * scale;
    var left = (textboxInfo.width-(5+4)) * scale;
    if (textDirection === TextDirection.RightToLeft) { // RTL hack
      left = 4 * scale;
    }

    for (var y = 0; y < 3; y++) {
      for (var x = 0; x < 5; x++) {
        var i = (y * 5) + x;
        if (arrowdata[i] == 1) {
          //scaling nonsense
          for (var sy = 0; sy < scale; sy++) {
            for (var sx = 0; sx < scale; sx++) {
              var pxl = 4 * ( ((top+(y*scale)+sy) * (textboxInfo.width*scale)) + (left+(x*scale)+sx) );
              textboxInfo.img.data[pxl+0] = 224;
              textboxInfo.img.data[pxl+1] = 208;
              textboxInfo.img.data[pxl+2] = 159;
              textboxInfo.img.data[pxl+3] = 255;
            }
          }
        }
      }
    }
  };

  var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
  this.DrawChar = function(char, row, col, leftPos) {
    char.offset = {
      x: char.base_offset.x,
      y: char.base_offset.y
    }; // compute render offset *every* frame

    char.SetPosition(row,col);
    char.ApplyEffects(effectTime);

    var charData = char.bitmap;

    var top = (4 * scale) + (row * 2 * scale) + (row * font.getHeight() * text_scale) + Math.floor( char.offset.y );
    var left = (4 * scale) + (leftPos * text_scale) + Math.floor( char.offset.x );

    var debug_r = Math.random() * 255;

    for (var y = 0; y < char.height; y++) {
      for (var x = 0; x < char.width; x++) {

        var i = (y * char.width) + x;
        if ( charData[i] == 1 ) {

          //scaling nonsense
          for (var sy = 0; sy < text_scale; sy++) {
            for (var sx = 0; sx < text_scale; sx++) {
              var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
              textboxInfo.img.data[pxl+0] = char.color.r;
              textboxInfo.img.data[pxl+1] = char.color.g;
              textboxInfo.img.data[pxl+2] = char.color.b;
              textboxInfo.img.data[pxl+3] = char.color.a;
            }
          }
        }
        // else {
        //  // DEBUG

        //  //scaling nonsense
        //  for (var sy = 0; sy < text_scale; sy++) {
        //    for (var sx = 0; sx < text_scale; sx++) {
        //      var pxl = 4 * ( ((top+(y*text_scale)+sy) * (textboxInfo.width*scale)) + (left+(x*text_scale)+sx) );
        //      textboxInfo.img.data[pxl+0] = debug_r;
        //      textboxInfo.img.data[pxl+1] = 0;
        //      textboxInfo.img.data[pxl+2] = 0;
        //      textboxInfo.img.data[pxl+3] = 255;
        //    }
        //  }
        // }

      }
    }
    
    // call printHandler for character
    char.OnPrint();
  };

  var effectTime = 0; // TODO this variable should live somewhere better
  this.Draw = function(buffer,dt) {
    effectTime += dt;

    this.ClearTextbox();

    buffer.ForEachActiveChar( this.DrawChar );

    if( buffer.CanContinue() )
      this.DrawNextArrow();

    this.DrawTextbox();

    if( buffer.DidPageFinishThisFrame() && onPageFinish != null )
      onPageFinish();
  };

  /* this is a hook for GIF rendering */
  var onPageFinish = null;
  this.SetPageFinishHandler = function(handler) {
    onPageFinish = handler;
  };

  this.Reset = function() {
    effectTime = 0;
    // TODO - anything else?
  }

  // this.CharsPerRow = function() {
  //  return textboxInfo.charsPerRow;
  // }
}


var DialogBuffer = function() {
  var buffer = [[[]]]; // holds dialog in an array buffer
  var pageIndex = 0;
  var rowIndex = 0;
  var charIndex = 0;
  var nextCharTimer = 0;
  var nextCharMaxTime = 50; // in milliseconds
  var isDialogReadyToContinue = false;
  var activeTextEffects = [];
  var font = null;
  var arabicHandler = new ArabicHandler();

  this.SetFont = function(f) {
    font = f;
  }

  this.CurPage = function() { return buffer[ pageIndex ]; };
  this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
  this.CurChar = function() { return this.CurRow()[ charIndex ]; };
  this.CurPageCount = function() { return buffer.length; };
  this.CurRowCount = function() { return this.CurPage().length; };
  this.CurCharCount = function() { return this.CurRow().length; };

  this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
    var rowCount = rowIndex + 1;
    for (var i = 0; i < rowCount; i++) {
      var row = this.CurPage()[i];
      var charCount = (i == rowIndex) ? charIndex+1 : row.length;
      // console.log(charCount);

      var leftPos = 0;
      if (textDirection === TextDirection.RightToLeft) {
        leftPos = 24 * 8; // hack -- I think this is correct?
      }

      for(var j = 0; j < charCount; j++) {
        var char = row[j];
        if(char) {
          if (textDirection === TextDirection.RightToLeft) {
            leftPos -= char.spacing;
          }
          // console.log(j + " " + leftPos);

          // handler( char, i /*rowIndex*/, j /*colIndex*/ );
          handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

          if (textDirection === TextDirection.LeftToRight) {
            leftPos += char.spacing;
          }
        }
      }
    }
  }

  this.Reset = function() {
    buffer = [[[]]];
    pageIndex = 0;
    rowIndex = 0;
    charIndex = 0;
    isDialogReadyToContinue = false;

    activeTextEffects = [];

    isActive = false;
  };

  this.DoNextChar = function() {
    // console.log("DO NEXT CHAR");

    nextCharTimer = 0; //reset timer

    //time to update characters
    if (charIndex + 1 < this.CurCharCount()) {
      //add char to current row
      charIndex++;
    }
    else if (rowIndex + 1 < this.CurRowCount()) {
      //start next row
      rowIndex++;
      charIndex = 0;
    }
    else {
      //the page is full!
      isDialogReadyToContinue = true;
      didPageFinishThisFrame = true;

      // console.log("WAITING FOR INPUT");
    }

    // console.log(this.CurChar());
    if(this.CurChar() != null)
      this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
  };

  this.Update = function(dt) {
    didPageFinishThisFrame = false;
    didFlipPageThisFrame = false;
    // this.Draw(dt); // TODO move into a renderer object
    if (isDialogReadyToContinue) {
      return; //waiting for dialog to be advanced by player
    }

    nextCharTimer += dt; //tick timer

    if (nextCharTimer > nextCharMaxTime) {
      this.DoNextChar();
    }
  };

  this.Skip = function() {
    console.log("SKIPPP");
    didPageFinishThisFrame = false;
    didFlipPageThisFrame = false;
    // add new characters until you get to the end of the current line of dialog
    while (rowIndex < this.CurRowCount()) {
      this.DoNextChar();

      if(isDialogReadyToContinue) {
        //make sure to push the rowIndex past the end to break out of the loop
        rowIndex++;
        charIndex = 0;
      }
    }
    rowIndex = this.CurRowCount()-1;
    charIndex = this.CurCharCount()-1;
  };

  this.FlipPage = function() {
    didFlipPageThisFrame = true;
    isDialogReadyToContinue = false;
    pageIndex++;
    rowIndex = 0;
    charIndex = 0;
  }

  this.EndDialog = function() {
    console.log("END!!!!");
    isActive = false; // no more text to show... this should be a sign to stop rendering dialog
  }

  this.Continue = function() {
    console.log("CONTINUE");
    if (pageIndex + 1 < this.CurPageCount()) {
      //start next page
      this.FlipPage();
      return true; /* hasMoreDialog */
    }
    else {
      //end dialog mode
      this.EndDialog();
      return false; /* hasMoreDialog */
    }
  };

  var isActive = false;
  this.IsActive = function() { return isActive; };

  this.CanContinue = function() { return isDialogReadyToContinue; };

  function DialogChar(effectList) {
    this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

    this.color = { r:209, g:184, b:136, a:255 };
    this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

    this.col = 0;
    this.row = 0;

    this.SetPosition = function(row,col) {
      // console.log("SET POS");
      // console.log(this);
      this.row = row;
      this.col = col;
    }

    this.ApplyEffects = function(time) {
      // console.log("APPLY EFFECTS! " + time);
      for(var i = 0; i < this.effectList.length; i++) {
        var effectName = this.effectList[i];
        // console.log("FX " + effectName);
        TextEffects[ effectName ].DoEffect( this, time );
      }
    }

    var printHandler = null; // optional function to be called once on printing character
    this.SetPrintHandler = function(handler) {
      printHandler = handler;
    }
    this.OnPrint = function() {
      if (printHandler != null) {
        console.log("PRINT HANDLER ---- DIALOG BUFFER");
        printHandler();
        printHandler = null; // only call handler once (hacky)
      }
    }

    this.bitmap = [];
    this.width = 0;
    this.height = 0;
    this.base_offset = { // hacky name
      x: 0,
      y: 0
    };
    this.spacing = 0;
  }

  function DialogFontChar(font, char, effectList) {
    Object.assign(this, new DialogChar(effectList));

    var charData = font.getChar(char);
    this.bitmap = charData.data;
    this.width = charData.width;
    this.height = charData.height;
    this.base_offset.x = charData.offset.x;
    this.base_offset.y = charData.offset.y;
    this.spacing = charData.spacing;
  }

  function DialogDrawingChar(drawingId, effectList) {
    Object.assign(this, new DialogChar(effectList));

    var imageData = renderer.GetImageSource(drawingId)[0];
    var imageDataFlat = [];
    for (var i = 0; i < imageData.length; i++) {
      // console.log(imageData[i]);
      imageDataFlat = imageDataFlat.concat(imageData[i]);
    }

    this.bitmap = imageDataFlat;
    this.width = 8;
    this.height = 8;
    this.spacing = 8;
  }

  function AddWordToCharArray(charArray,word,effectList) {
    for(var i = 0; i < word.length; i++) {
      charArray.push( new DialogFontChar( font, word[i], effectList ) );
    }
    return charArray;
  }

  function GetCharArrayWidth(charArray) {
    var width = 0;
    for(var i = 0; i < charArray.length; i++) {
      width += charArray[i].spacing;
    }
    return width;
  }

  function GetStringWidth(str) {
    var width = 0;
    for (var i = 0; i < str.length; i++) {
      var charData = font.getChar(str[i]);
      width += charData.spacing;
    }
    return width;
  }

  var pixelsPerRow = 192; // hard-coded fun times!!!

  this.AddDrawing = function(drawingId, onFinishHandler) {
    // console.log("DRAWING ID " + drawingId);

    var curPageIndex = buffer.length - 1;
    var curRowIndex = buffer[curPageIndex].length - 1;
    var curRowArr = buffer[curPageIndex][curRowIndex];

    var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects)
    drawingChar.SetPrintHandler( onFinishHandler );

    var rowLength = GetCharArrayWidth(curRowArr);

    // TODO : clean up copy-pasted code here :/
    if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0)
    {
      //stay on same row
      curRowArr.push( drawingChar );
    }
    else if (curRowIndex == 0)
    {
      //start next row
      buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
      buffer[ curPageIndex ].push( [] );
      curRowIndex++;
      curRowArr = buffer[ curPageIndex ][ curRowIndex ];
      curRowArr.push( drawingChar );
    }
    else {
      //start next page
      buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
      buffer.push( [] );
      curPageIndex++;
      buffer[ curPageIndex ].push( [] );
      curRowIndex = 0;
      curRowArr = buffer[ curPageIndex ][ curRowIndex ];
      curRowArr.push( drawingChar );
    }

    isActive = true; // this feels like a bad way to do this???
  }

  // TODO : convert this into something that takes DialogChar arrays
  this.AddText = function(textStr,onFinishHandler) {
    // console.log("ADD TEXT " + textStr);

    //process dialog so it's easier to display
    var words = textStr.split(" ");

    // var curPageIndex = this.CurPageCount() - 1;
    // var curRowIndex = this.CurRowCount() - 1;
    // var curRowArr = this.CurRow();

    var curPageIndex = buffer.length - 1;
    var curRowIndex = buffer[curPageIndex].length - 1;
    var curRowArr = buffer[curPageIndex][curRowIndex];

    for (var i = 0; i < words.length; i++) {
      var word = words[i];
      if (arabicHandler.ContainsArabicCharacters(word)) {
        word = arabicHandler.ShapeArabicCharacters(word);
      }

      var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
      var wordLength = GetStringWidth( wordWithPrecedingSpace );

      var rowLength = GetCharArrayWidth(curRowArr);

      if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
        //stay on same row
        curRowArr = AddWordToCharArray( curRowArr, wordWithPrecedingSpace, activeTextEffects );
      }
      else if (curRowIndex == 0) {
        //start next row
        buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
        buffer[ curPageIndex ].push( [] );
        curRowIndex++;
        curRowArr = buffer[ curPageIndex ][ curRowIndex ];
        curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
      }
      else {
        //start next page
        buffer[ curPageIndex ][ curRowIndex ] = curRowArr;
        buffer.push( [] );
        curPageIndex++;
        buffer[ curPageIndex ].push( [] );
        curRowIndex = 0;
        curRowArr = buffer[ curPageIndex ][ curRowIndex ];
        curRowArr = AddWordToCharArray( curRowArr, word, activeTextEffects );
      }
    }

    //destroy any empty stuff
    var lastPage = buffer[ buffer.length-1 ];
    var lastRow = lastPage[ lastPage.length-1 ];
    if( lastRow.length == 0 )
      lastPage.splice( lastPage.length-1, 1 );
    if( lastPage.length == 0 )
      buffer.splice( buffer.length-1, 1 );

    //finish up 
    lastPage = buffer[ buffer.length-1 ];
    lastRow = lastPage[ lastPage.length-1 ];
    if( lastRow.length > 0 ) {
      var lastChar = lastRow[ lastRow.length-1 ];
      lastChar.SetPrintHandler( onFinishHandler );
    }

    console.log(buffer);

    isActive = true;
  };

  this.AddLinebreak = function() {
    var lastPage = buffer[ buffer.length-1 ];
    if( lastPage.length <= 1 ) {
      console.log("LINEBREAK - NEW ROW ");
      // add new row
      lastPage.push( [] );
    }
    else {
      // add new page
      buffer.push( [[]] );
    }
    console.log(buffer);

    isActive = true;
  }

  /* new text effects */
  this.HasTextEffect = function(name) {
    return activeTextEffects.indexOf( name ) > -1;
  }
  this.AddTextEffect = function(name) {
    activeTextEffects.push( name );
  }
  this.RemoveTextEffect = function(name) {
    activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
  }

  /* this is a hook for GIF rendering */
  var didPageFinishThisFrame = false;
  this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

  var didFlipPageThisFrame = false;
  this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

  // this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

  var arabicCharStart = 0x0621;
  var arabicCharEnd = 0x064E;

  var CharacterForm = {
    Isolated : 0,
    Final : 1,
    Initial : 2,
    Middle : 3
  };

  // map glyphs to their character forms
  var glyphForms = {
    /*     Isolated, Final, Initial, Middle Forms */
    0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
    0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
    0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
    0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
    0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
    0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
    0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
    0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
    0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
    0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
    0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
    0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
    0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
    0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
    0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
    0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
    0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
    0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
    0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
    0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
    0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
    0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
    0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
    0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
    0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
    0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
    0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
    0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
    0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
    0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
    0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
    0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
    0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
    0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
    0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
    0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
    0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
    0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
    0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
    0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
    0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
    0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
    0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
    0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
    0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
    0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
  };

  var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

  function IsArabicCharacter(char) {
    var code = char.charCodeAt(0);
    return (code >= arabicCharStart && code <= arabicCharEnd);
  }

  function ContainsArabicCharacters(word) {
    for (var i = 0; i < word.length; i++) {
      if (IsArabicCharacter(word[i])) {
        return true;
      }
    }
    return false;
  }

  function IsDisconnectedCharacter(char) {
    var code = char.charCodeAt(0);
    return disconnectedCharacters.indexOf(code) != -1;
  }

  function ShapeArabicCharacters(word) {
    var shapedWord = "";

    for (var i = 0; i < word.length; i++) {
      if (!IsArabicCharacter(word[i])) {
        shapedWord += word[i];
        continue;
      }

      var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

      var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

      var form;
      if (!connectedToPreviousChar && !connectedToNextChar) {
        form = CharacterForm.Isolated;
      }
      else if (connectedToPreviousChar && !connectedToNextChar) {
        form = CharacterForm.Final;
      }
      else if (!connectedToPreviousChar && connectedToNextChar) {
        form = CharacterForm.Initial;
      }
      else if (connectedToPreviousChar && connectedToNextChar) {
        form = CharacterForm.Middle;
      }

      var code = word[i].charCodeAt(0);

      // handle lam alef special case
      if (code == 0x0644 && connectedToNextChar) {
        var nextCode = word[i+1].charCodeAt(0);
        var specialCode = null;
        if (nextCode == 0x0622) {
          // alef madd
          specialCode = glyphForms[0x064b][form];
        }
        else if (nextCode == 0x0623) {
          // hamza above
          specialCode = glyphForms[0x064c][form];
        }
        else if (nextCode == 0x0625) {
          // hamza below
          specialCode = glyphForms[0x064d][form];
        }
        else if (nextCode == 0x0627) {
          // alef
          specialCode = glyphForms[0x064e][form];
        }

        if (specialCode != null) {
          shapedWord += String.fromCharCode(specialCode);
          i++; // skip a step
          continue;
        }
      }

      // hacky?
      if (form === CharacterForm.Isolated) {
        shapedWord += word[i];
        continue;
      }

      var shapedCode = glyphForms[code][form];
      shapedWord += String.fromCharCode(shapedCode);
    }

    return shapedWord;
  }

  this.ContainsArabicCharacters = ContainsArabicCharacters;
  this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = new Map();

var RainbowEffect = function() { // TODO - should it be an object or just a method?
  this.DoEffect = function(char,time) {
    // console.log("RAINBOW!!!");
    // console.log(char);
    // console.log(char.color);
    // console.log(char.col);

    var h = Math.abs( Math.sin( (time / 600) - (char.col / 8) ) );
    var rgb = hslToRgb( h, 1, 0.5 );
    char.color.r = rgb[0];
    char.color.g = rgb[1];
    char.color.b = rgb[2];
    char.color.a = 255;
  }
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
  this.DoEffect = function(char) {
    var pal = getPal( curPal() );
    var color = pal[ parseInt( index ) ];
    // console.log(color);
    char.color.r = color[0];
    char.color.g = color[1];
    char.color.b = color[2];
    char.color.a = 255;
  }
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
  this.DoEffect = function(char,time) {
    char.offset.y += Math.sin( (time / 250) - (char.col / 2) ) * 4;
  }
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
  function disturb(func,time,offset,mult1,mult2) {
    return func( (time * mult1) - (offset * mult2) );
  }

  this.DoEffect = function(char,time) {
    char.offset.y += 3
            * disturb(Math.sin,time,char.col,0.1,0.5)
            * disturb(Math.cos,time,char.col,0.3,0.2)
            * disturb(Math.sin,time,char.row,2.0,1.0);
    char.offset.x += 3
            * disturb(Math.cos,time,char.row,0.1,1.0)
            * disturb(Math.sin,time,char.col,3.0,0.7)
            * disturb(Math.cos,time,char.col,0.2,0.3);
  }
};
TextEffects["shk"] = new ShakyEffect();

} // Dialog()
</script>

<script>
/*
TODO
- reset renderer function
- react to changes in: drawings, palettes
- possible future plan: limit size of cache (remove old images)
- change image store path from (pal > col > draw) to (draw > pal > col)
- get rid of old getSpriteImage (etc) methods
- get editor working again [in progress]
- move debug timer class into core (seems useful)
*/

function Renderer(tilesize, scale) {

console.log("!!!!! NEW RENDERER");

var imageStore = { // TODO : rename to imageCache
  source: {},
  render: {}
};

var palettes = null; // TODO : need null checks?
var context = null;

function setPalettes(paletteObj) {
  palettes = paletteObj;

  // TODO : should this really clear out the render cache?
  imageStore.render = {};
}

function getPaletteColor(paletteId, colorIndex) {
  var palette = palettes[paletteId];

  if (colorIndex > palette.colors.length) { // do I need this failure case? (seems un-reliable)
    colorIndex = 0;
  }

  var color = palette.colors[colorIndex];

  return {
    r : color[0],
    g : color[1],
    b : color[2]
  };
}

var debugRenderCount = 0;

// TODO : change image store path from (pal > col > draw) to (draw > pal > col)
function renderImage(drawing, paletteId) {
  // debugRenderCount++;
  // console.log("RENDER COUNT " + debugRenderCount);

  var col = drawing.col;
  var colStr = "" + col;
  var pal = paletteId;
  var drwId = drawing.drw;
  var imgSrc = imageStore.source[ drawing.drw ];

  // initialize render cache entry
  if (imageStore.render[drwId] === undefined || imageStore.render[drwId] === null) {
    imageStore.render[drwId] = {};
  }

  if (imageStore.render[drwId][pal] === undefined || imageStore.render[drwId][pal] === null) {
    imageStore.render[drwId][pal] = {};
  }

  // create array of ImageData frames
  imageStore.render[drwId][pal][colStr] = [];

  for (var i = 0; i < imgSrc.length; i++) {
    var frameSrc = imgSrc[i];
    var frameData = imageDataFromImageSource( frameSrc, pal, col );
    imageStore.render[drwId][pal][colStr].push(frameData);
  }
}

function imageDataFromImageSource(imageSource, pal, col) {
  //console.log(imageSource);

  var img = context.createImageData(tilesize*scale,tilesize*scale);

  var backgroundColor = getPaletteColor(pal,0);
  var foregroundColor = getPaletteColor(pal,col);

  for (var y = 0; y < tilesize; y++) {
    for (var x = 0; x < tilesize; x++) {
      var px = imageSource[y][x];
      for (var sy = 0; sy < scale; sy++) {
        for (var sx = 0; sx < scale; sx++) {
          var pxl = (((y * scale) + sy) * tilesize * scale * 4) + (((x*scale) + sx) * 4);
          if ( px === 1 ) {
            img.data[pxl + 0] = foregroundColor.r;
            img.data[pxl + 1] = foregroundColor.g;
            img.data[pxl + 2] = foregroundColor.b;
            img.data[pxl + 3] = 255;
          }
          else { //ch === 0
            img.data[pxl + 0] = backgroundColor.r;
            img.data[pxl + 1] = backgroundColor.g;
            img.data[pxl + 2] = backgroundColor.b;
            img.data[pxl + 3] = 255;
          }
        }
      }
    }
  }

  return img;
}

// TODO : move into core
function undefinedOrNull(x) {
  return x === undefined || x === null;
}

function isImageRendered(drawing, paletteId) {
  var col = drawing.col;
  var colStr = "" + col;
  var pal = paletteId;
  var drwId = drawing.drw;

  if (undefinedOrNull(imageStore.render[drwId]) ||
    undefinedOrNull(imageStore.render[drwId][pal]) ||
    undefinedOrNull(imageStore.render[drwId][pal][colStr])) {
      return false;
  }
  else {
    return true;
  }
}

function getImageSet(drawing, paletteId) {
  return imageStore.render[drawing.drw][paletteId][drawing.col];
}

function getImageFrame(drawing, paletteId, frameOverride) {
  var frameIndex = 0;
  if (drawing.animation.isAnimated) {
    if (frameOverride != undefined && frameOverride != null) {
      frameIndex = frameOverride;
    }
    else {
      frameIndex = drawing.animation.frameIndex;
    }
  }

  return getImageSet(drawing, paletteId)[frameIndex];
}

function getOrRenderImage(drawing, paletteId, frameOverride) {
  if (!isImageRendered(drawing, paletteId)) {
    renderImage(drawing, paletteId);
  }

  return getImageFrame(drawing, paletteId, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetImage = getOrRenderImage;

this.SetPalettes = setPalettes;

this.SetImageSource = function(drawingId, imageSourceData) {
  imageStore.source[drawingId] = imageSourceData;
  imageStore.render[drawingId] = {}; // reset render cache for this image
}

this.GetImageSource = function(drawingId) {
  return imageStore.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
  return imageStore.source[drawingId].length;
}

this.AttachContext = function(ctx) {
  context = ctx;
}

} // Renderer()
</script>

<script>
var xhr; // TODO : remove
var canvas;
var context; // TODO : remove if safe?
var ctx;

var title = "";
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = {
  "0" : [[0,0,0],[255,0,0],[255,255,255]] //start off with a default palette (can be overriden)
};
var ending = {};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
  LeftToRight : "LTR",
  RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

var names = {
  room : new Map(),
  tile : new Map(), // Note: Not currently enabled in the UI
  sprite : new Map(),
  item : new Map(),
  /*dialog : new Map()*/ // TODO
  /*ending : new Map()*/ // TODO
};
function updateNamesFromCurData() {
  names.room = new Map();
  for(id in room) {
    if(room[id].name != undefined && room[id].name != null)
      names.room.set( room[id].name, id );
  }
  names.tile = new Map();
  for(id in tile) {
    if(tile[id].name != undefined && tile[id].name != null)
      names.tile.set( tile[id].name, id );
  }
  names.sprite = new Map();
  for(id in sprite) {
    if(sprite[id].name != undefined && sprite[id].name != null)
      names.sprite.set( sprite[id].name, id );
  }
  names.item = new Map();
  for(id in item) {
    if(item[id].name != undefined && item[id].name != null)
      names.item.set( item[id].name, id );
  }
}

var spriteStartLocations = {};

/* VERSION */
var version = {
  major: 5, // major changes
  minor: 5 // smaller changes
};
function getEngineVersion() {
  return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
  flags = {
    ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
  };
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
  // NONE right now!
};

function clearGameData() {
  title = "";
  room = {};
  tile = {};
  sprite = {};
  item = {};
  dialog = {};
  palette = { //start off with a default palette (can be overriden)
    "0" : {
      name : null,
      colors : [[0,0,0],[255,0,0],[255,255,255]]
    }
  };
  ending = {};
  isEnding = false; //todo - correct place for this?
  variable = {};

  // TODO RENDERER : clear data?

  spriteStartLocations = {};

  names = {
    room : new Map(),
    tile : new Map(),
    sprite : new Map(),
    item : new Map()
  };

  fontName = defaultFontName; // TODO : reset font manager too?
  textDirection = TextDirection.LeftToRight;
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var key = {
  left : 37,
  right : 39,
  up : 38,
  down : 40,
  space : 32,
  enter : 13,
  w : 87,
  a : 65,
  s : 83,
  d : 68,
  r : 82,
  shift : 16,
  ctrl : 17,
  alt : 18,
  cmd : 224
};

var prevTime = 0;
var deltaTime = 0;

//methods used to trigger gif recording
var didPlayerMoveThisFrame = false;
var onPlayerMoved = null;
// var didDialogUpdateThisFrame = false;
var onDialogUpdate = null;

//inventory update UI handles
var onInventoryChanged = null;
var onVariableChanged = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new Renderer(tilesize, scale);

function getGameNameFromURL() {
  var game = window.location.hash.substring(1);
  // console.log("game name --- " + game);
  return game;
}

function attachCanvas(c) {
  canvas = c;
  canvas.width = width * scale;
  canvas.height = width * scale;
  ctx = canvas.getContext("2d");
  dialogRenderer.AttachContext(ctx);
  renderer.AttachContext(ctx);
}

var curGameData = null;
function load_game(game_data, startWithTitle) {
  curGameData = game_data; //remember the current game (used to reset the game)

  dialogBuffer.Reset();
  scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

  parseWorld(game_data);

  if (!isPlayerEmbeddedInEditor) {
    // hack to ensure default font is available
    fontManager.AddResource(defaultFontName + fontManager.GetExtension(), document.getElementById(defaultFontName).text.slice(1));
  }

  var font = fontManager.Get( fontName );
  dialogBuffer.SetFont(font);
  dialogRenderer.SetFont(font);

  setInitialVariables();

  // setInterval(updateLoadingScreen, 300); // hack test

  onready(startWithTitle);
}

function reset_cur_game() {
  if (curGameData == null) return; //can't reset if we don't have the game data
  stopGame();
  clearGameData();
  load_game(curGameData);
}

var update_interval = null;
function onready(startWithTitle) {
  if(startWithTitle === undefined || startWithTitle === null) startWithTitle = true;

  clearInterval(loading_interval);

  input = new InputManager();

  document.addEventListener('keydown', input.onkeydown);
  document.addEventListener('keyup', input.onkeyup);

  if (isPlayerEmbeddedInEditor) {
    canvas.addEventListener('touchstart', input.ontouchstart);
    canvas.addEventListener('touchmove', input.ontouchmove);
    canvas.addEventListener('touchend', input.ontouchend);
  }
  else {
    //borksy modification, fixing touch controls on itch.io mobile embeds

    let existingTouchTrigger = document.querySelector('#touchTrigger');
    if (existingTouchTrigger === null){
      var touchTrigger = document.createElement("div");
      touchTrigger.setAttribute("id","touchTrigger");
      touchTrigger.setAttribute(
        "style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
      );
      document.body.appendChild(touchTrigger);

      touchTrigger.addEventListener('touchstart', input.ontouchstart);
      touchTrigger.addEventListener('touchmove', input.ontouchmove);
      touchTrigger.addEventListener('touchend', input.ontouchend);
    }
  }

  window.onblur = input.onblur;

  update_interval = setInterval(update,-1);

  console.log("TITLE ??? " + startWithTitle);
  if(startWithTitle) // used by editor
    startNarrating(title);
}

function setInitialVariables() {
  for(id in variable) {
    var value = variable[id]; // default to string
    if(value === "true") {
      value = true;
    }
    else if(value === "false") {
      value = false;
    }
    else if(!isNaN(parseFloat(value))) {
      value = parseFloat(value);
    }
    scriptInterpreter.SetVariable(id,value);
  }
  scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

// TODO: this is likely broken
function breadthFirstSearch(map, from, to) {
  from.trail = [];
  var visited = [];
  var queue = [from];
  visited.push( posToString(from) );

  //console.log( "~ bfs ~");
  //console.log( posToString(from) + " to " + posToString(to) );

  while ( queue.length > 0 ) {

    //grab pos from queue and mark as visited
    var curPos = queue.shift();

    //console.log( posToString(curPos) );
    //console.log( ".. " + pathToString(curPos.trail) );
    //console.log( visited );

    if (curPos.x == to.x && curPos.y == to.y) {
      //found a path!
      var path = curPos.trail.splice(0);
      path.push( curPos );
      return path;
    }

    //look at neighbors
    neighbors(curPos).forEach( function(n) {
      var inBounds = (n.x >= 0 && n.x < 16 && n.y >= 0 && n.y < 16);
      if (inBounds) {
        var noCollision = map[n.y][n.x] <= 0;
        var notVisited = visited.indexOf( posToString(n) ) == -1;
        if (noCollision && notVisited) {
          n.trail = curPos.trail.slice();
          n.trail.push(curPos);
          queue.push( n );
          visited.push( posToString(n) );
        }
      }
    });

  }

  return []; // no path found
}

function posToString(pos) {
  return pos.x + "," + pos.y;
}

function pathToString(path) {
  var s = "";
  for (i in path) {
    s += posToString(path[i]) + " ";
  }
  return s;
}

function neighbors(pos) {
  var neighborList = [];
  neighborList.push( {x:pos.x+1, y:pos.y+0} );
  neighborList.push( {x:pos.x-1, y:pos.y+0} );
  neighborList.push( {x:pos.x+0, y:pos.y+1} );
  neighborList.push( {x:pos.x+0, y:pos.y-1} );
  return neighborList;
}

function collisionMap(roomId) {
  var map = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
  ];

  for (r in room[roomId].tilemap) {
    var row = room[roomId].tilemap[r];
    for (var c = 0; c < row.length; c++) {
      if (room[roomId].walls.indexOf( row[x] ) != -1) {
        map[r][c] = 1;
      }
    }
  }

  for (id in sprite) {
    var spr = sprite[id];
    if (spr.room === roomId) {
      map[spr.y][spr.x] = 2;
    }
  }

  return map;
}

function getOffset(evt) {
  var offset = { x:0, y:0 };

  var el = evt.target;
  var rect = el.getBoundingClientRect();

  offset.x += rect.left + el.scrollLeft;
  offset.y += rect.top + el.scrollTop;

  offset.x = evt.clientX - offset.x;
  offset.y = evt.clientY - offset.y;

  return offset;
}

function stopGame() {
  console.log("stop GAME!");

  document.removeEventListener('keydown', input.onkeydown);
  document.removeEventListener('keyup', input.onkeyup);

  if (isPlayerEmbeddedInEditor) {
    canvas.removeEventListener('touchstart', input.ontouchstart);
    canvas.removeEventListener('touchmove', input.ontouchmove);
    canvas.removeEventListener('touchend', input.ontouchend);
  }
  else {

    //borksy modifications

    let existingTouchTrigger = document.querySelector('#touchTrigger');
    if (existingTouchTrigger !== null){
      existingTouchTrigger.removeEventListener('touchstart', input.ontouchstart);
      existingTouchTrigger.removeEventListener('touchmove', input.ontouchmove);
      existingTouchTrigger.removeEventListener('touchend', input.ontouchend);

      existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
    }
  }

  window.onblur = null;

  clearInterval(update_interval);
}

/* loading animation */
var loading_anim_data = [
  [
    0,1,1,1,1,1,1,0,
    0,0,1,1,1,1,0,0,
    0,0,1,1,1,1,0,0,
    0,0,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,
    0,0,1,0,0,1,0,0,
    0,0,1,0,0,1,0,0,
    0,1,1,1,1,1,1,0,
  ],
  [
    0,1,1,1,1,1,1,0,
    0,0,1,0,0,1,0,0,
    0,0,1,1,1,1,0,0,
    0,0,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,
    0,0,1,0,0,1,0,0,
    0,0,1,1,1,1,0,0,
    0,1,1,1,1,1,1,0,
  ],
  [
    0,1,1,1,1,1,1,0,
    0,0,1,0,0,1,0,0,
    0,0,1,0,0,1,0,0,
    0,0,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,
    0,0,1,1,1,1,0,0,
    0,0,1,1,1,1,0,0,
    0,1,1,1,1,1,1,0,
  ],
  [
    0,1,1,1,1,1,1,0,
    0,0,1,0,0,1,0,0,
    0,0,1,0,0,1,0,0,
    0,0,0,1,1,0,0,0,
    0,0,0,1,1,0,0,0,
    0,0,1,1,1,1,0,0,
    0,0,1,1,1,1,0,0,
    0,1,1,1,1,1,1,0,
  ],
  [
    0,0,0,0,0,0,0,0,
    1,0,0,0,0,0,0,1,
    1,1,1,0,0,1,1,1,
    1,1,1,1,1,0,0,1,
    1,1,1,1,1,0,0,1,
    1,1,1,0,0,1,1,1,
    1,0,0,0,0,0,0,1,
    0,0,0,0,0,0,0,0,
  ]
];
var loading_anim_frame = 0;
var loading_anim_speed = 500;
var loading_interval = null;

function loadingAnimation() {
  //create image
  var loadingAnimImg = ctx.createImageData(8*scale, 8*scale);
  //draw image
  for (var y = 0; y < 8; y++) {
    for (var x = 0; x < 8; x++) {
      var i = (y * 8) + x;
      if (loading_anim_data[loading_anim_frame][i] == 1) {
        //scaling nonsense
        for (var sy = 0; sy < scale; sy++) {
          for (var sx = 0; sx < scale; sx++) {
            var pxl = 4 * ( (((y*scale)+sy) * (8*scale)) + ((x*scale)+sx) );
            loadingAnimImg.data[pxl+0] = 255;
            loadingAnimImg.data[pxl+1] = 255;
            loadingAnimImg.data[pxl+2] = 255;
            loadingAnimImg.data[pxl+3] = 255;
          }
        }
      }
    }
  }
  //put image on canvas
  ctx.putImageData(loadingAnimImg,scale*(width/2 - 4),scale*(height/2 - 4));
  //update frame
  loading_anim_frame++;
  if (loading_anim_frame >= 5) loading_anim_frame = 0;
}

function updateLoadingScreen() {
  // TODO : in progress
  ctx.fillStyle = "rgb(0,0,0)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  loadingAnimation();
  drawSprite( getSpriteImage(sprite["a"],"0",0), 8, 8, ctx );
}

function update() {
  var curTime = Date.now();
  deltaTime = curTime - prevTime;

  updateInput();

  if (!isNarrating && !isEnding) {
    updateAnimation();
    drawRoom( room[curRoom] ); // draw world if game has begun
  }
  else {
    //make sure to still clear screen
    ctx.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // if (isDialogMode) { // dialog mode
  if(dialogBuffer.IsActive()) {
    dialogRenderer.Draw( dialogBuffer, deltaTime );
    dialogBuffer.Update( deltaTime );
  }
  else if (!isEnding) {
    moveSprites();
  }

  // keep moving avatar if player holds down button
  if( !dialogBuffer.IsActive() && !isEnding )
  {
    if( curPlayerDirection != Direction.None ) {
      playerHoldToMoveTimer -= deltaTime;

      if( playerHoldToMoveTimer <= 0 )
      {
        movePlayer( curPlayerDirection );
        playerHoldToMoveTimer = 150;
      }
    }
  }

  prevTime = curTime;

  //for gif recording
  if (didPlayerMoveThisFrame && onPlayerMoved != null) onPlayerMoved();
  didPlayerMoveThisFrame = false;
  // if (didDialogUpdateThisFrame && onDialogUpdate != null) onDialogUpdate();
  // didDialogUpdateThisFrame = false;
  /* hacky replacement */
  if (onDialogUpdate != null)
    dialogRenderer.SetPageFinishHandler( onDialogUpdate );

  input.resetKeyPressed();
  input.resetTapReleased();
}

function updateInput() {
  if( dialogBuffer.IsActive() ) {
    if (input.anyKeyPressed() || input.isTapReleased()) {
      /* CONTINUE DIALOG */
      if (dialogBuffer.CanContinue()) {
        var hasMoreDialog = dialogBuffer.Continue();
        if(!hasMoreDialog) {
          // ignore currently held keys UNTIL they are released (stops player from insta-moving)
          input.ignoreHeldKeys();

          onExitDialog();
        }
      }
      else {
        dialogBuffer.Skip();
      }
    }
  }
  else if ( isEnding ) {
    if (input.anyKeyPressed() || input.isTapReleased()) {
      /* RESTART GAME */
      reset_cur_game();
    }
  }
  else {
    /* WALK */
    var prevPlayerDirection = curPlayerDirection;

    if ( input.isKeyDown( key.left ) || input.isKeyDown( key.a ) || input.swipeLeft() ) {
      curPlayerDirection = Direction.Left;
    }
    else if ( input.isKeyDown( key.right ) || input.isKeyDown( key.d ) || input.swipeRight() ) {
      curPlayerDirection = Direction.Right;
    }
    else if ( input.isKeyDown( key.up ) || input.isKeyDown( key.w ) || input.swipeUp() ) {
      curPlayerDirection = Direction.Up;
    }
    else if ( input.isKeyDown( key.down ) || input.isKeyDown( key.s ) || input.swipeDown() ) {
      curPlayerDirection = Direction.Down;
    }
    else {
      curPlayerDirection = Direction.None;
    }

    if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
      movePlayer( curPlayerDirection );
      playerHoldToMoveTimer = 500;
    }
  }
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
  animationCounter += deltaTime;

  if ( animationCounter >= animationTime ) {

    // animate sprites
    for (id in sprite) {
      var spr = sprite[id];
      if (spr.animation.isAnimated) {
        spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
      }
    }

    // animate tiles
    for (id in tile) {
      var til = tile[id];
      if (til.animation.isAnimated) {
        til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
      }
    }

    // animate items
    for (id in item) {
      var itm = item[id];
      if (itm.animation.isAnimated) {
        itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
      }
    }

    // reset counter
    animationCounter = 0;

  }
}

var moveCounter = 0;
var moveTime = 200;
function moveSprites() {
  moveCounter += deltaTime;

  if (moveCounter >= moveTime) {

    for (id in sprite) {
      var spr = sprite[id];
      if (spr.walkingPath.length > 0) {
        //move sprite
        var nextPos = spr.walkingPath.shift();
        spr.x = nextPos.x;
        spr.y = nextPos.y;


        var end = getEnding( spr.room, spr.x, spr.y );
        var ext = getExit( spr.room, spr.x, spr.y );
        var itmIndex = getItemIndex( spr.room, spr.x, spr.y );
        if (end) { //if the sprite hits an ending
          if (id === playerId) { // only the player can end the game
            startNarrating( ending[end.id], true /*isEnding*/ );
          }
        }
        else if (ext) { //if the sprite hits an exit
          //move it to another scene
          spr.room = ext.dest.room;
          spr.x = ext.dest.x;
          spr.y = ext.dest.y;
          if (id === playerId) {
            //if the player changes scenes, change the visible scene
            curRoom = ext.dest.room;
          }
        }
        else if(itmIndex > -1) {
          var itm = room[ spr.room ].items[ itmIndex ];
          room[ spr.room ].items.splice( itmIndex, 1 );
          if( spr.inventory[ itm.id ] )
            spr.inventory[ itm.id ] += 1;
          else
            spr.inventory[ itm.id ] = 1;

          if(onInventoryChanged != null)
            onInventoryChanged( itm.id );

          if(id === playerId)
            startItemDialog( itm.id  /*itemId*/ );

          // stop moving : is this a good idea?
          spr.walkingPath = [];
        }

        if (id === playerId) didPlayerMoveThisFrame = true;
      }
    }

    moveCounter = 0;
  }

}

function getSpriteAt(x,y) {
  for (id in sprite) {
    var spr = sprite[id];
    if (spr.room === curRoom) {
      if (spr.x == x && spr.y == y) {
        return id;
      }
    }
  }
  return null;
}

var Direction = {
  None : -1,
  Up : 0,
  Down : 1,
  Left : 2,
  Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

var InputManager = function() {
  var self = this;

  var pressed;
  var ignored;
  var newKeyPress;
  var touchState;

  function resetAll() {
    pressed = {};
    ignored = {};
    newKeyPress = false;

    touchState = {
      isDown : false,
      startX : 0,
      startY : 0,
      curX : 0,
      curY : 0,
      swipeDistance : 30,
      swipeDirection : Direction.None,
      tapReleased : false
    };
  }
  resetAll();

  function stopWindowScrolling(e) {
    if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
      e.preventDefault();
  }

  function tryRestartGame(e) {
    /* RESTART GAME */
    if ( e.keyCode === key.r && ( e.getModifierState("Control") || e.getModifierState("Meta") ) ) {
      if ( confirm("Restart the game?") ) {
        reset_cur_game();
      }
    }
  }

  function eventIsModifier(event) {
    return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
  }

  function isModifierKeyDown() {
    return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
  }

  this.ignoreHeldKeys = function() {
    for (var key in pressed) {
      if (pressed[key]) { // only ignore keys that are actually held
        ignored[key] = true;
        // console.log("IGNORE -- " + key);
      }
    }
  }

  this.onkeydown = function(event) {
    // console.log("KEYDOWN -- " + event.keyCode);

    stopWindowScrolling(event);

    tryRestartGame(event);

    // Special keys being held down can interfere with keyup events and lock movement
    // so just don't collect input when they're held
    {
      if (isModifierKeyDown()) {
        return;
      }

      if (eventIsModifier(event)) {
        resetAll();
      }
    }

    if (ignored[event.keyCode]) {
      return;
    }

    if (!self.isKeyDown(event.keyCode)) {
      newKeyPress = true;
    }

    pressed[event.keyCode] = true;
    ignored[event.keyCode] = false;
  }

  this.onkeyup = function(event) {
    // console.log("KEYUP -- " + event.keyCode);
    pressed[event.keyCode] = false;
    ignored[event.keyCode] = false;
  }

  this.ontouchstart = function(event) {
    if( event.cancelable){
      event.preventDefault();
    }

    if( event.changedTouches.length > 0 ) {
      touchState.isDown = true;

      touchState.startX = touchState.curX = event.changedTouches[0].clientX;
      touchState.startY = touchState.curY = event.changedTouches[0].clientY;

      touchState.swipeDirection = Direction.None;
    }
  }

  this.ontouchmove = function(event) {
    if( event.cancelable){
      event.preventDefault();
    }

    if( touchState.isDown && event.changedTouches.length > 0 ) {
      touchState.curX = event.changedTouches[0].clientX;
      touchState.curY = event.changedTouches[0].clientY;

      var prevDirection = touchState.swipeDirection;

      if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
        touchState.swipeDirection = Direction.Left;
      }
      else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
        touchState.swipeDirection = Direction.Right;
      }
      else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
        touchState.swipeDirection = Direction.Up;
      }
      else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
        touchState.swipeDirection = Direction.Down;
      }

      if( touchState.swipeDirection != prevDirection ) {
        // reset center so changing directions is easier
        touchState.startX = touchState.curX;
        touchState.startY = touchState.curY;
      }
    }
  }

  this.ontouchend = function(event) {
    if( event.cancelable){
      event.preventDefault();
    }

    touchState.isDown = false;

    if( touchState.swipeDirection == Direction.None ) {
      // tap!
      touchState.tapReleased = true;
    }

    touchState.swipeDirection = Direction.None;
  }

  this.isKeyDown = function(keyCode) {
    return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
  }

  this.anyKeyPressed = function() {
    return newKeyPress;
  }

  this.resetKeyPressed = function() {
    newKeyPress = false;
  }

  this.swipeLeft = function() {
    return touchState.swipeDirection == Direction.Left;
  }

  this.swipeRight = function() {
    return touchState.swipeDirection == Direction.Right;
  }

  this.swipeUp = function() {
    return touchState.swipeDirection == Direction.Up;
  }

  this.swipeDown = function() {
    return touchState.swipeDirection == Direction.Down;
  }

  this.isTapReleased = function() {
    return touchState.tapReleased;
  }

  this.resetTapReleased = function() {
    touchState.tapReleased = false;
  }

  this.onblur = function() {
    // console.log("~~~ BLUR ~~");
    resetAll();
  }
}
var input = null;

function movePlayer(direction) {
  var spr = null;

  if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
    player().x -= 1;
    didPlayerMoveThisFrame = true;
  }
  else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
    player().x += 1;
    didPlayerMoveThisFrame = true;
  }
  else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
    player().y -= 1;
    didPlayerMoveThisFrame = true;
  }
  else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
    player().y += 1;
    didPlayerMoveThisFrame = true;
  }
  
  var ext = getExit( player().room, player().x, player().y );
  var end = getEnding( player().room, player().x, player().y );
  var itmIndex = getItemIndex( player().room, player().x, player().y );

  // do items first, because you can pick up an item AND go through a door
  if (itmIndex > -1) {
    // TODO pick up items (what about touch?)
    // console.log("HIT ITM ");
    // console.log( itmIndex );
    var itm = room[ player().room ].items[ itmIndex ];
    // console.log(itm);
    room[ player().room ].items.splice( itmIndex, 1 );
    if( player().inventory[ itm.id ] )
      player().inventory[ itm.id ] += 1;
    else
      player().inventory[ itm.id ] = 1;

    if(onInventoryChanged != null)
      onInventoryChanged( itm.id );

    startItemDialog( itm.id  /*itemId*/ );

    // console.log( player().inventory );
  }

  if (end) {
    startNarrating( ending[end.id], true /*isEnding*/ );
  }
  else if (ext) {
    player().room = ext.dest.room;
    player().x = ext.dest.x;
    player().y = ext.dest.y;
    curRoom = ext.dest.room;
  }
  else if (spr) {
    startSpriteDialog( spr /*spriteId*/ );
  }
}

function getItemIndex( roomId, x, y ) {
  for( var i = 0; i < room[roomId].items.length; i++ ) {
    var itm = room[roomId].items[i];
    if ( itm.x == x && itm.y == y)
      return i;
  }
  return -1;
}

function getSpriteLeft() { //repetitive?
  return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
  return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
  return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
  return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
  return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
  return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
  return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
  return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
  if(roomId == undefined || roomId == null)
    roomId = curRoom;

  var tileId = getTile( x, y );

  if( tileId === '0' )
    return false; // Blank spaces aren't walls, ya doofus

  if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
    // No wall-state defined: check room-specific walls
    var i = room[roomId].walls.indexOf( getTile(x,y) );
    return i > -1;
  }

  // Otherwise, use the tile's own wall-state
  return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
  for (i in room[roomId].items) {
    var item = room[roomId].items[i];
    if (x == item.x && y == item.y) {
      return item;
    }
  }
  return null;
}

function getExit(roomId,x,y) {
  for (i in room[roomId].exits) {
    var e = room[roomId].exits[i];
    if (x == e.x && y == e.y) {
      return e;
    }
  }
  return null;
}

function getEnding(roomId,x,y) {
  for (i in room[roomId].endings) {
    var e = room[roomId].endings[i];
    if (x == e.x && y == e.y) {
      return e;
    }
  }
  return null;
}

function getTile(x,y) {
  // console.log(x + " " + y);
  var t = getRoom().tilemap[y][x];
  return t;
}

function player() {
  return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
  return palette[ id ].colors;
}

function getRoom() {
  return room[curRoom];
}

function isSpriteOffstage(id) {
  return sprite[id].room == null;
}

function parseWorld(file) {
  // console.log("~~~ PARSE WORLD ~~~");
  // console.log(file);

  // var parseTimer = new Timer();

  resetFlags();

  var versionNumber = 0;

  var lines = file.split("\n");
  var i = 0;
  while (i < lines.length) {
    var curLine = lines[i];

    // console.log(lines[i]);

    if (i == 0) {
      i = parseTitle(lines, i);
    }
    else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
      // collect version number (from a comment.. hacky I know)
      if (curLine.indexOf("# BITSY VERSION ") != -1) {
        versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));
      }

      //skip blank lines & comments
      i++;
    }
    else if (getType(curLine) == "PAL") {
      i = parsePalette(lines, i);
    }
    else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
      i = parseRoom(lines, i);
    }
    else if (getType(curLine) === "TIL") {
      i = parseTile(lines, i);
    }
    else if (getType(curLine) === "SPR") {
      i = parseSprite(lines, i);
    }
    else if (getType(curLine) === "ITM") {
      i = parseItem(lines, i);
    }
    else if (getType(curLine) === "DRW") {
      i = parseDrawing(lines, i);
    }
    else if (getType(curLine) === "DLG") {
      i = parseDialog(lines, i);
    }
    else if (getType(curLine) === "END") {
      i = parseEnding(lines, i);
    }
    else if (getType(curLine) === "VAR") {
      i = parseVariable(lines, i);
    }
    else if (getType(curLine) === "DEFAULT_FONT") {
      i = parseFontName(lines, i);
    }
    else if (getType(curLine) === "TEXT_DIRECTION") {
      i = parseTextDirection(lines, i);
    }
    else if (getType(curLine) === "FONT") {
      i = parseFontData(lines, i);
    }
    else if (getType(curLine) === "!") {
      i = parseFlag(lines, i);
    }
    else {
      i++;
    }
  }
  placeSprites();
  if (player().room != null) {
    curRoom = player().room;
  }

  renderer.SetPalettes(palette);

  // console.log(names);

  // console.log("~~~~~ PARSE TIME " + parseTimer.Milliseconds());

  return versionNumber;
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
  if (skipFonts === undefined || skipFonts === null)
    skipFonts = false;

  var worldStr = "";
  /* TITLE */
  worldStr += title + "\n";
  worldStr += "\n";
  /* VERSION */
  worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
  worldStr += "\n";
  /* FLAGS */
  for (f in flags) {
    worldStr += "! " + f + " " + flags[f] + "\n";
  }
  worldStr += "\n"
  /* FONT */
  if (fontName != defaultFontName) {
    worldStr += "DEFAULT_FONT " + fontName + "\n";
    worldStr += "\n"
  }
  if (textDirection != TextDirection.LeftToRight) {
    worldStr += "TEXT_DIRECTION " + textDirection + "\n";
    worldStr += "\n"
  }
  /* PALETTE */
  for (id in palette) {
    worldStr += "PAL " + id + "\n";
    if( palette[id].name != null )
      worldStr += "NAME " + palette[id].name + "\n";
    for (i in getPal(id)) {
      for (j in getPal(id)[i]) {
        worldStr += getPal(id)[i][j];
        if (j < 2) worldStr += ",";
      }
      worldStr += "\n";
    }
    worldStr += "\n";
  }
  /* ROOM */
  for (id in room) {
    worldStr += "ROOM " + id + "\n";
    if ( flags.ROOM_FORMAT == 0 ) {
      // old non-comma separated format
      for (i in room[id].tilemap) {
        for (j in room[id].tilemap[i]) {
          worldStr += room[id].tilemap[i][j]; 
        }
        worldStr += "\n";
      }
    }
    else if ( flags.ROOM_FORMAT == 1 ) {
      // new comma separated format
      for (i in room[id].tilemap) {
        for (j in room[id].tilemap[i]) {
          worldStr += room[id].tilemap[i][j];
          if (j < room[id].tilemap[i].length-1) worldStr += ","
        }
        worldStr += "\n";
      }
    }
    if (room[id].name != null) {
      /* NAME */
      worldStr += "NAME " + room[id].name + "\n";
    }
    if (room[id].walls.length > 0) {
      /* WALLS */
      worldStr += "WAL ";
      for (j in room[id].walls) {
        worldStr += room[id].walls[j];
        if (j < room[id].walls.length-1) {
          worldStr += ",";
        }
      }
      worldStr += "\n";
    }
    if (room[id].items.length > 0) {
      /* ITEMS */
      for (j in room[id].items) {
        var itm = room[id].items[j];
        worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
        worldStr += "\n";
      }
    }
    if (room[id].exits.length > 0) {
      /* EXITS */
      for (j in room[id].exits) {
        var e = room[id].exits[j];
        if ( isExitValid(e) ) {
          worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
          worldStr += "\n";
        }
      }
    }
    if (room[id].endings.length > 0) {
      /* ENDINGS */
      for (j in room[id].endings) {
        var e = room[id].endings[j];
        // todo isEndingValid
        worldStr += "END " + e.id + " " + e.x + "," + e.y;
        worldStr += "\n";
      }
    }
    if (room[id].pal != null) {
      /* PALETTE */
      worldStr += "PAL " + room[id].pal + "\n";
    }
    worldStr += "\n";
  }
  /* TILES */
  for (id in tile) {
    worldStr += "TIL " + id + "\n";
    worldStr += serializeDrawing( "TIL_" + id );
    if (tile[id].name != null && tile[id].name != undefined) {
      /* NAME */
      worldStr += "NAME " + tile[id].name + "\n";
    }
    if (tile[id].isWall != null && tile[id].isWall != undefined) {
      /* WALL */
      worldStr += "WAL " + tile[id].isWall + "\n";
    }
    if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
      /* COLOR OVERRIDE */
      worldStr += "COL " + tile[id].col + "\n";
    }
    worldStr += "\n";
  }
  /* SPRITES */
  for (id in sprite) {
    worldStr += "SPR " + id + "\n";
    worldStr += serializeDrawing( "SPR_" + id );
    if (sprite[id].name != null && sprite[id].name != undefined) {
      /* NAME */
      worldStr += "NAME " + sprite[id].name + "\n";
    }
    if (sprite[id].dlg != null) {
      worldStr += "DLG " + sprite[id].dlg + "\n";
    }
    if (sprite[id].room != null) {
      /* SPRITE POSITION */
      worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
    }
    if (sprite[id].inventory != null) {
      for(itemId in sprite[id].inventory) {
        worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
      }
    }
    if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
      /* COLOR OVERRIDE */
      worldStr += "COL " + sprite[id].col + "\n";
    }
    worldStr += "\n";
  }
  /* ITEMS */
  for (id in item) {
    worldStr += "ITM " + id + "\n";
    worldStr += serializeDrawing( "ITM_" + id );
    if (item[id].name != null && item[id].name != undefined) {
      /* NAME */
      worldStr += "NAME " + item[id].name + "\n";
    }
    if (item[id].dlg != null) {
      worldStr += "DLG " + item[id].dlg + "\n";
    }
    if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
      /* COLOR OVERRIDE */
      worldStr += "COL " + item[id].col + "\n";
    }
    worldStr += "\n";
  }
  /* DIALOG */
  for (id in dialog) {
    worldStr += "DLG " + id + "\n";
    worldStr += dialog[id] + "\n";
    worldStr += "\n";
  }
  /* ENDINGS */
  for (id in ending) {
    worldStr += "END " + id + "\n";
    worldStr += ending[id] + "\n";
    worldStr += "\n";
  }
  /* VARIABLES */
  for (id in variable) {
    worldStr += "VAR " + id + "\n";
    worldStr += variable[id] + "\n";
    worldStr += "\n";
  }
  /* FONT */
  // TODO : support multiple fonts
  if (fontName != defaultFontName && !skipFonts) {
    worldStr += fontManager.GetData(fontName);
  }

  return worldStr;
}

function serializeDrawing(drwId) {
  var imageSource = renderer.GetImageSource(drwId);
  var drwStr = "";
  for (f in imageSource) {
    for (y in imageSource[f]) {
      var rowStr = "";
      for (x in imageSource[f][y]) {
        rowStr += imageSource[f][y][x];
      }
      drwStr += rowStr + "\n";
    }
    if (f < (imageSource.length-1)) drwStr += ">\n";
  }
  return drwStr;
}

function isExitValid(e) {
  var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
  var hasDest = e.dest != null;
  var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
  return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
  for (id in spriteStartLocations) {
    //console.log(id);
    //console.log( spriteStartLocations[id] );
    //console.log(sprite[id]);
    sprite[id].room = spriteStartLocations[id].room;
    sprite[id].x = spriteStartLocations[id].x;
    sprite[id].y = spriteStartLocations[id].y;
    //console.log(sprite[id]);
  }
}

/* ARGUMENT GETTERS */
function getType(line) {
  return getArg(line,0);
}

function getId(line) {
  return getArg(line,1);
}

function getArg(line,arg) {
  return line.split(" ")[arg];
}

function getCoord(line,arg) {
  return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
  title = lines[i];
  i++;
  return i;
}

function parseRoom(lines, i) {
  var id = getId(lines[i]);
  room[id] = {
    id : id,
    tilemap : [],
    walls : [],
    exits : [],
    endings : [],
    items : [],
    pal : null,
    name : null
  };
  i++;

  // create tile map
  if ( flags.ROOM_FORMAT == 0 ) {
    // old way: no commas, single char tile ids
    var end = i + mapsize;
    var y = 0;
    for (; i<end; i++) {
      room[id].tilemap.push( [] );
      for (x = 0; x<mapsize; x++) {
        room[id].tilemap[y].push( lines[i].charAt(x) );
      }
      y++;
    }
  }
  else if ( flags.ROOM_FORMAT == 1 ) {
    // new way: comma separated, multiple char tile ids
    var end = i + mapsize;
    var y = 0;
    for (; i<end; i++) {
      room[id].tilemap.push( [] );
      var lineSep = lines[i].split(",");
      for (x = 0; x<mapsize; x++) {
        room[id].tilemap[y].push( lineSep[x] );
      }
      y++;
    }
  }

  while (i < lines.length && lines[i].length > 0) { //look for empty line
    // console.log(getType(lines[i]));
    if (getType(lines[i]) === "SPR") {
      /* NOTE SPRITE START LOCATIONS */
      var sprId = getId(lines[i]);
      if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
        /* PLACE A SINGLE SPRITE */
        var sprCoord = lines[i].split(" ")[2].split(",");
        spriteStartLocations[sprId] = {
          room : id,
          x : parseInt(sprCoord[0]),
          y : parseInt(sprCoord[1])
        };
      }
      else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
        /* PLACE MULTIPLE SPRITES*/ 
        //Does find and replace in the tilemap (may be hacky, but its convenient)
        var sprList = sprId.split(",");
        for (row in room[id].tilemap) {
          for (s in sprList) {
            var col = room[id].tilemap[row].indexOf( sprList[s] );
            //if the sprite is in this row, replace it with the "null tile" and set its starting position
            if (col != -1) {
              room[id].tilemap[row][col] = "0";
              spriteStartLocations[ sprList[s] ] = {
                room : id,
                x : parseInt(col),
                y : parseInt(row)
              };
            }
          }
        }
      }
    }
    else if (getType(lines[i]) === "ITM") {
      var itmId = getId(lines[i]);
      var itmCoord = lines[i].split(" ")[2].split(",");
      var itm = {
        id: itmId,
        x : parseInt(itmCoord[0]),
        y : parseInt(itmCoord[1])
      };
      room[id].items.push( itm );
    }
    else if (getType(lines[i]) === "WAL") {
      /* DEFINE COLLISIONS (WALLS) */
      room[id].walls = getId(lines[i]).split(",");
    }
    else if (getType(lines[i]) === "EXT") {
      /* ADD EXIT */
      var exitArgs = lines[i].split(" ");
      //arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
      var exitCoords = exitArgs[1].split(",");
      var destName = exitArgs[2];
      var destCoords = exitArgs[3].split(",");
      var ext = {
        x : parseInt(exitCoords[0]),
        y : parseInt(exitCoords[1]),
        dest : {
          room : destName,
          x : parseInt(destCoords[0]),
          y : parseInt(destCoords[1])
        }
      };
      room[id].exits.push(ext);
    }
    else if (getType(lines[i]) === "END") {
      /* ADD ENDING */
      var endId = getId( lines[i] );
      var endCoords = getCoord( lines[i], 2 );
      var end = {
        id : endId,
        x : parseInt( endCoords[0] ),
        y : parseInt( endCoords[1] )
      };
      room[id].endings.push(end);
    }
    else if (getType(lines[i]) === "PAL") {
      /* CHOOSE PALETTE (that's not default) */
      room[id].pal = getId(lines[i]);
    }
    else if (getType(lines[i]) === "NAME") {
      var name = lines[i].split(/\s(.+)/)[1];
      room[id].name = name;
      names.room.set( name, id);
    }
    i++;
  }
  return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
  var id = getId(lines[i]);
  i++;
  var colors = [];
  var name = null;
  while (i < lines.length && lines[i].length > 0) { //look for empty line
    var args = lines[i].split(" ");
    if(args[0] === "NAME") {
      name = lines[i].split(/\s(.+)/)[1];
    }
    else {
      var col = [];
      lines[i].split(",").forEach(function(i) {
        col.push(parseInt(i));
      });
      colors.push(col);
    }
    i++;
  }
  palette[id] = {
    id : id,
    name : name,
    colors : colors
  };
  return i;
}

function parseTile(lines, i) {
  var id = getId(lines[i]);
  var drwId = null;
  var name = null;

  i++;

  if (getType(lines[i]) === "DRW") { //load existing drawing
    drwId = getId(lines[i]);
    i++;
  }
  else {
    // store tile source
    drwId = "TIL_" + id;
    i = parseDrawingCore( lines, i, drwId );
  }

  //other properties
  var colorIndex = 1; // default palette color index is 1
  var isWall = null; // null indicates it can vary from room to room (original version)
  while (i < lines.length && lines[i].length > 0) { //look for empty line
    if (getType(lines[i]) === "COL") {
      colorIndex = parseInt( getId(lines[i]) );
    }
    else if (getType(lines[i]) === "NAME") {
      /* NAME */
      name = lines[i].split(/\s(.+)/)[1];
      names.tile.set( name, id );
    }
    else if (getType(lines[i]) === "WAL") {
      var wallArg = getArg( lines[i], 1 );
      if( wallArg === "true" ) {
        isWall = true;
      }
      else if( wallArg === "false" ) {
        isWall = false;
      }
    }
    i++;
  }

  //tile data
  tile[id] = {
    id : id,
    drw : drwId, //drawing id
    col : colorIndex,
    animation : {
      isAnimated : (renderer.GetFrameCount(drwId) > 1),
      frameIndex : 0,
      frameCount : renderer.GetFrameCount(drwId)
    },
    name : name,
    isWall : isWall
  };

  return i;
}

function parseSprite(lines, i) {
  var id = getId(lines[i]);
  var drwId = null;
  var name = null;

  i++;

  if (getType(lines[i]) === "DRW") { //load existing drawing
    drwId = getId(lines[i]);
    i++;
  }
  else {
    // store sprite source
    drwId = "SPR_" + id;
    i = parseDrawingCore( lines, i, drwId );
  }

  //other properties
  var colorIndex = 2; //default palette color index is 2
  var dialogId = null;
  var startingInventory = {};
  while (i < lines.length && lines[i].length > 0) { //look for empty line
    if (getType(lines[i]) === "COL") {
      /* COLOR OFFSET INDEX */
      colorIndex = parseInt( getId(lines[i]) );
    }
    else if (getType(lines[i]) === "POS") {
      /* STARTING POSITION */
      var posArgs = lines[i].split(" ");
      var roomId = posArgs[1];
      var coordArgs = posArgs[2].split(",");
      spriteStartLocations[id] = {
        room : roomId,
        x : parseInt(coordArgs[0]),
        y : parseInt(coordArgs[1])
      };
    }
    else if(getType(lines[i]) === "DLG") {
      dialogId = getId(lines[i]);
    }
    else if (getType(lines[i]) === "NAME") {
      /* NAME */
      name = lines[i].split(/\s(.+)/)[1];
      names.sprite.set( name, id );
    }
    else if (getType(lines[i]) === "ITM") {
      /* ITEM STARTING INVENTORY */
      var itemId = getId(lines[i]);
      var itemCount = parseFloat( getArg(lines[i], 2) );
      startingInventory[itemId] = itemCount;
    }
    i++;
  }

  //sprite data
  sprite[id] = {
    id : id,
    drw : drwId, //drawing id
    col : colorIndex,
    dlg : dialogId,
    room : null, //default location is "offstage"
    x : -1,
    y : -1,
    walkingPath : [], //tile by tile movement path (isn't saved)
    animation : {
      isAnimated : (renderer.GetFrameCount(drwId) > 1),
      frameIndex : 0,
      frameCount : renderer.GetFrameCount(drwId)
    },
    inventory : startingInventory,
    name : name
  };
  return i;
}

function parseItem(lines, i) {
  var id = getId(lines[i]);
  var drwId = null;
  var name = null;

  i++;

  if (getType(lines[i]) === "DRW") { //load existing drawing
    drwId = getId(lines[i]);
    i++;
  }
  else {
    // store item source
    drwId = "ITM_" + id; // these prefixes are maybe a terrible way to differentiate drawing tyepes :/
    i = parseDrawingCore( lines, i, drwId );
  }

  //other properties
  var colorIndex = 2; //default palette color index is 2
  var dialogId = null;
  while (i < lines.length && lines[i].length > 0) { //look for empty line
    if (getType(lines[i]) === "COL") {
      /* COLOR OFFSET INDEX */
      colorIndex = parseInt( getArg( lines[i], 1 ) );
    }
    // else if (getType(lines[i]) === "POS") {
    //  /* STARTING POSITION */
    //  var posArgs = lines[i].split(" ");
    //  var roomId = posArgs[1];
    //  var coordArgs = posArgs[2].split(",");
    //  spriteStartLocations[id] = {
    //    room : roomId,
    //    x : parseInt(coordArgs[0]),
    //    y : parseInt(coordArgs[1])
    //  };
    // }
    else if(getType(lines[i]) === "DLG") {
      dialogId = getId(lines[i]);
    }
    else if (getType(lines[i]) === "NAME") {
      /* NAME */
      name = lines[i].split(/\s(.+)/)[1];
      names.item.set( name, id );
    }
    i++;
  }

  //item data
  item[id] = {
    id : id,
    drw : drwId, //drawing id
    col : colorIndex,
    dlg : dialogId,
    // room : null, //default location is "offstage"
    // x : -1,
    // y : -1,
    animation : {
      isAnimated : (renderer.GetFrameCount(drwId) > 1),
      frameIndex : 0,
      frameCount : renderer.GetFrameCount(drwId)
    },
    name : name
  };

  // console.log("ITM " + id);
  // console.log(item[id]);

  return i;
}

function parseDrawing(lines, i) {
  // store drawing source
  var drwId = getId( lines[i] );
  return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
  var frameList = []; //init list of frames
  frameList.push( [] ); //init first frame
  var frameIndex = 0;
  var y = 0;
  while ( y < tilesize ) {
    var l = lines[i+y];
    var row = [];
    for (x = 0; x < tilesize; x++) {
      row.push( parseInt( l.charAt(x) ) );
    }
    frameList[frameIndex].push( row );
    y++;

    if (y === tilesize) {
      i = i + y;
      if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
        // start next frame!
        frameList.push( [] );
        frameIndex++;
        //start the count over again for the next frame
        i++;
        y = 0;
      }
    }
  }

  renderer.SetImageSource(drwId, frameList);

  return i;
}

function parseDialog(lines, i) {
  var id = getId(lines[i]);
  i++;

  // TODO : use this for titles & endings too
  var results = scriptInterpreter.ReadDialogScript(lines,i);
  dialog[id] = results.script;
  i = results.index;

  return i;
}

function parseEnding(lines, i) {
  var id = getId(lines[i]);
  i++;
  var text = lines[i];
  i++;
  ending[id] = text;
  return i;
}

function parseVariable(lines, i) {
  var id = getId(lines[i]);
  i++;
  var value = lines[i];
  i++;
  variable[id] = value;
  return i;
}

function parseFontName(lines, i) {
  fontName = getArg(lines[i], 1);
  i++;
  return i;
}

function parseTextDirection(lines, i) {
  textDirection = getArg(lines[i], 1);
  i++;
  return i;
}

function parseFontData(lines, i) {
  // NOTE : we're not doing the actual parsing here --
  // just grabbing the block of text that represents the font
  // and giving it to the font manager to use later

  var localFontName = getId(lines[i]);
  var localFontData = lines[i];
  i++;

  while (i < lines.length && lines[i] != "") {
    localFontData += "\n" + lines[i];
    i++;
  }

  var localFontFilename = localFontName + fontManager.GetExtension();
  fontManager.AddResource( localFontFilename, localFontData );

  return i;
}

function parseFlag(lines, i) {
  var id = getId(lines[i]);
  var valStr = lines[i].split(" ")[2];
  flags[id] = parseInt( valStr );
  i++;
  return i;
}

function drawTile(img,x,y,context) {
  if (!context) { //optional pass in context; otherwise, use default
    context = ctx;
  }
  context.putImageData(img,x*tilesize*scale,y*tilesize*scale);
}

function drawSprite(img,x,y,context) { //this may differ later (or not haha)
  drawTile(img,x,y,context);
}

function drawItem(img,x,y,context) {
  drawTile(img,x,y,context); //TODO these methods are dumb and repetitive
}

function drawRoom(room,context,frameIndex) { // context & frameIndex are optional
  if (!context) { //optional pass in context; otherwise, use default (ok this is REAL hacky isn't it)
    context = ctx;
  }

  //clear screen
  context.fillStyle = "rgb(" + getPal(curPal())[0][0] + "," + getPal(curPal())[0][1] + "," + getPal(curPal())[0][2] + ")";
  context.fillRect(0,0,canvas.width,canvas.height);

  //draw tiles
  for (i in room.tilemap) {
    for (j in room.tilemap[i]) {
      var id = room.tilemap[i][j];
      if (id != "0") {
        //console.log(id);
        if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
          id = "0";
          room.tilemap[i][j] = id;
        }
        else {
          // console.log(id);
          drawTile( getTileImage(tile[id],getRoomPal(room.id),frameIndex), j, i, context );
        }
      }
    }
  }

  //draw items
  for (var i = 0; i < room.items.length; i++) {
    var itm = room.items[i];
    drawItem( getItemImage(item[itm.id],getRoomPal(room.id),frameIndex), itm.x, itm.y, context );
  }

  //draw sprites
  for (id in sprite) {
    var spr = sprite[id];
    if (spr.room === room.id) {
      drawSprite( getSpriteImage(spr,getRoomPal(room.id),frameIndex), spr.x, spr.y, context );
    }
  }
}

// TODO : remove these get*Image methods
function getTileImage(t,palId,frameIndex) {
  return renderer.GetImage(t,palId,frameIndex);
}

function getSpriteImage(s,palId,frameIndex) {
  return renderer.GetImage(s,palId,frameIndex);
}

function getItemImage(itm,palId,frameIndex) {
  return renderer.GetImage(itm,palId,frameIndex);
}

function curPal() {
  return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
  if (room[roomId].pal != null) {
    //a specific palette was chosen
    return room[roomId].pal;
  }
  else {
    if (roomId in palette) {
      //there is a palette matching the name of the room
      return roomId;
    }
    else {
      //use the default palette
      return "0";
    }
  }
  return "0"; 
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

function onExitDialog() {
  // var breakShit = null;
  // breakShit();
  console.log("EXIT DIALOG");
  isDialogMode = false;
  if (isNarrating) isNarrating = false;
  if (isDialogPreview) {
    isDialogPreview = false;
    if (onDialogPreviewEnd != null)
      onDialogPreviewEnd();
  }
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
  console.log("NARRATE " + dialogStr);

  if(end === undefined) end = false;

  isNarrating = true;
  isEnding = end;
  startDialog(dialogStr);
}

function startItemDialog(itemId) {
  var dialogId = item[itemId].dlg;
  // console.log("START ITEM DIALOG " + dialogId);
  if(dialog[dialogId]){
    var dialogStr = dialog[dialogId];
    startDialog(dialogStr,dialogId);
  }
}

function startSpriteDialog(spriteId) {
  var spr = sprite[spriteId];
  var dialogId = spr.dlg ? spr.dlg : spriteId;
  // console.log("START SPRITE DIALOG " + dialogId);
  if(dialog[dialogId]){
    var dialogStr = dialog[dialogId];
    startDialog(dialogStr,dialogId);
  }
}

function startDialog(dialogStr,scriptId) {
  console.log("START DIALOG ");
  console.log(dialogStr);

  if(dialogStr.length <= 0) {
    console.log("ON EXIT DIALOG -- startDialog 1");
    onExitDialog();
    return;
  }

  isDialogMode = true;

  dialogRenderer.Reset();
  dialogRenderer.SetCentered( isNarrating /*centered*/ );
  dialogBuffer.Reset();
  scriptInterpreter.SetDialogBuffer( dialogBuffer );

  var onScriptEnd = function() {
    if(!dialogBuffer.IsActive()){
      console.log("ON EXIT DIALOG -- startDialog 2");
      onExitDialog();
    }
  };

  if(scriptId === undefined) {
    scriptInterpreter.Interpret( dialogStr, onScriptEnd );    
  }
  else {
    if( !scriptInterpreter.HasScript(scriptId) )
      scriptInterpreter.Compile( scriptId, dialogStr );
    scriptInterpreter.Run( scriptId, onScriptEnd );
  }

}

var isDialogPreview = false;
function startPreviewDialog(script, onScriptEnd) {
  isNarrating = true;

  isDialogMode = true;

  isDialogPreview = true;

  dialogRenderer.Reset();
  dialogRenderer.SetCentered( true );
  dialogBuffer.Reset();
  scriptInterpreter.SetDialogBuffer( dialogBuffer );

  onDialogPreviewEnd = onScriptEnd;

  scriptInterpreter.Eval( script, null );
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
</script>

<!-- store default font in separate script tag for back compat-->
<script type="bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

<!-- BORKSY HACKS -->
<script type="text/javascript" id="borksyHacks">
//borksy uses dist versions of hacks from the bitsy hacks repo now

/**
🔀
@file logic-operators-extended
@summary adds conditional logic operators
@version 1.1.0
@author @mildmojo

@description
Adds conditional logic operators:
  - !== (not equal to)
  - && (and)
  - || (or)
  - &&! (and not)
  - ||! (or not)

Examples: candlecount > 5 && haslighter == 1
          candlecount > 5 && papercount > 1 && isIndoors
          haslighter == 1 || hasmatches == 1
          candlecount > 5 && candlecount !== 666
          candlecount > 5 &&! droppedlighter
          droppedlighter ||! hasmatches

NOTE: The combining operators (&&, ||, &&!, ||!) have lower precedence than
      all other math and comparison operators, so it might be hard to write
      tests that mix and match these new operators and have them evaluate
      correctly. If you're using multiple `&&` and `||` operators in one
      condition, be sure to test every possibility to make sure it behaves
      the way you want.
*/
this.hacks = this.hacks || {};
(function (bitsy) {
'use strict';

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 3.2.2
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	kitsy.queuedInjectScripts.push({
		searchRegex: searchRegex,
		replaceString: replaceString
	});
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var superFn = bitsy[functionName];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	bitsy[functionName] = function () {
		var args = [].slice.call(arguments);
		var i = 0;
		runBefore.apply(this, arguments);

		// Iterate thru sync & async functions. Run each, finally run original.
		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				var newArgs = functions[i++].apply(this, args);
				newArgs = newArgs && newArgs.length ? newArgs : args;
				runBefore.apply(this, newArgs);
			}
		}
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}



inject$1(/(operatorMap\.set\("-", subExp\);)/,[
	'$1',
	'operatorMap.set("&&", andExp);',
	'operatorMap.set("||", orExp);',
	'operatorMap.set("&&!", andNotExp);',
	'operatorMap.set("||!", orNotExp);',
	'operatorMap.set("!==", notEqExp);'
].join('\n'));
inject$1(
	/(var operatorSymbols = \["-", "\+", "\/", "\*", "<=", ">=", "<", ">", "=="\];)/,
	'$1operatorSymbols.unshift("!==", "&&", "||", "&&!", "||!");'
);

bitsy.andExp = function andExp(environment, left, right, onReturn) {
	right.Eval(environment, function (rVal) {
		left.Eval(environment, function (lVal) {
			onReturn(lVal && rVal);
		});
	});
};

bitsy.orExp = function orExp(environment, left, right, onReturn) {
	right.Eval(environment, function (rVal) {
		left.Eval(environment, function (lVal) {
			onReturn(lVal || rVal);
		});
	});
};

bitsy.notEqExp = function notEqExp(environment, left, right, onReturn) {
	right.Eval(environment, function (rVal) {
		left.Eval(environment, function (lVal) {
			onReturn(lVal !== rVal);
		});
	});
};

bitsy.andNotExp = function andNotExp(environment, left, right, onReturn) {
	right.Eval(environment, function (rVal) {
		left.Eval(environment, function (lVal) {
			onReturn(lVal && !rVal);
		});
	});
};

bitsy.orNotExp = function orNotExp(environment, left, right, onReturn) {
	right.Eval(environment, function (rVal) {
		left.Eval(environment, function (lVal) {
			onReturn(lVal || !rVal);
		});
	});
};
// End of logic operators mod

}(window));

/**
⏳
@file permanent items
@summary prevent some items from being picked up
@license MIT
@version 2.0.0
@author Sean S. LeBlanc

@description
Prevents certain items from being picked up, but allows them to be walked over and triggers their dialog.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Update the `itemIsPermanent` function below to match your needs
*/
(function (bitsy) {
'use strict';
var hackOptions = {
itemIsPermanent: function (item) {
  // specific permanent item
  //return item.name == 'tea';

  // specific permanent item list
  // return ['credits1', 'credits2'].indexOf(item.name) !== -1;

  // permanent item flag in name
  return item.name.indexOf('PERMANENT') !== -1;
  
  // all items are permanent
  //return true;
}
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*helper used to inject code into script tags based on a search string*/
function inject(searchString, codeToInject) {
	var args = [].slice.call(arguments);
	codeToInject = flatten(args.slice(1)).join('');

	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.indexOf(searchString) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchString + '" in script tags';
	}

	// modify the content
	code = code.replace(searchString, searchString + codeToInject);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

function flatten(list) {
	if (!Array.isArray(list)) {
		return list;
	}

	return list.reduce(function (fragments, arg) {
		return fragments.concat(flatten(arg));
	}, []);
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 2.1.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchString, codeFragment1[, ...codefragmentN]);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchString, injectScript.codeFragments);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var superFn = bitsy[functionName];
	var superFnLength = superFn.length;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	functions.push(superFn);
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	bitsy[functionName] = function () {
		var args = [].slice.call(arguments);
		var i = 0;
		runBefore.apply(this, arguments);

		// Iterate thru sync & async functions. Run each, finally run original.
		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				var newArgs = functions[i++].apply(this, args) || args;
				runBefore.apply(this, newArgs);
			}
		}
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}





var room;
var oldItems;
before("movePlayer", function () {
	room = bitsy.room[bitsy.curRoom];
	oldItems = room.items.slice();
});
after("movePlayer", function () {
	var newItems = room.items;
	if (newItems.length === oldItems.length) {
		return; // nothing changed
	}

	// check for changes
	for (var i = 0; i < oldItems.length; ++i) {
		if (!newItems[i] ||
			oldItems[i].x !== newItems[i].x ||
			oldItems[i].y !== newItems[i].y ||
			oldItems[i].id !== newItems[i].id
		) {
			// something changed
			if (hackOptions.itemIsPermanent(bitsy.item[oldItems[i].id])) {
				// put that back!
				newItems.splice(i, 0, oldItems[i]);
			} else {
				// add an empty entry for now to keep the arrays aligned
				newItems.splice(i, 0, null);
			}
		}
	}
	// clear out those empty entries
	room.items = newItems.filter(function (item) {
		return !!item;
	});
});

}(window));

/**
🚪
@file exit-from-dialog
@summary exit to another room from dialog, including conditionals
@license WTFPL (do WTF you want)
@version 5.2.0
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
Lets you exit to another room from dialog (including inside conditionals). Use
it to make an invisible sprite that acts as a conditional exit, use it to warp
somewhere after a conversation, use it to put a guard at your gate who only
lets you in once you're disguised, use it to require payment before the
ferryman will take you across the river.

Using the (exit) function in any part of a series of dialog will make the
game exit to the new room after the dialog is finished. Using (exitNow) will
immediately warp to the new room, but the current dialog will continue.

WARNING: In exit coordinates, the TOP LEFT tile is (0,0). In sprite coordinates,
         the BOTTOM LEFT tile is (0,0). If you'd like to use sprite coordinates,
         add the word "sprite" as the fourth parameter to the exit function.

Usage: (exit "<room name>,<x>,<y>")
       (exit "<room name>,<x>,<y>,sprite")
       (exitNow "<room name>,<x>,<y>")
       (exitNow "<room name>,<x>,<y>,sprite")

Example: (exit "FinalRoom,8,4")
         (exitNow "FinalRoom,8,11,sprite")

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/
this.hacks = this.hacks || {};
(function (bitsy) {
'use strict';

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting room by name or id
 * @param {string} name id or name of room to return
 * @return {string} room, or undefined if it doesn't exist
 */
function getRoom(name) {
	var id = bitsy.room.hasOwnProperty(name) ? name : bitsy.names.room.get(name);
	return bitsy.room[id];
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 3.2.2
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	kitsy.queuedInjectScripts.push({
		searchRegex: searchRegex,
		replaceString: replaceString
	});
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var superFn = bitsy[functionName];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	bitsy[functionName] = function () {
		var args = [].slice.call(arguments);
		var i = 0;
		runBefore.apply(this, arguments);

		// Iterate thru sync & async functions. Run each, finally run original.
		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				var newArgs = functions[i++].apply(this, args);
				newArgs = newArgs && newArgs.length ? newArgs : args;
				runBefore.apply(this, newArgs);
			}
		}
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function(match, group){
			if(match.substr(0,1) === '\\') {
				return '('+ group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{'+ group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}


function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		throw new Error('The dialog function "' + tag + '" already exists.');
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (game_data) {
		return [convertDialogTags(game_data, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", function(e, p, o){ kitsy.deferredDialogFunctions.' + tag + '.push({e:e,p:p}); o(null); });'
	);
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}



// Implement the {exit} dialog function. It saves the room name and
// destination X/Y coordinates so we can travel there after the dialog is over.
addDeferredDialogTag('exit', function (environment, parameters) {
	var exitParams = _getExitParams('exit', parameters);
	if (!exitParams) {
		return;
	}

	doPlayerExit(exitParams);
});

// Implement the {exitNow} dialog function. It exits to the destination room
// and X/Y coordinates right damn now.
addDialogTag('exitNow', function (environment, parameters, onReturn) {
	var exitParams = _getExitParams('exitNow', parameters);
	if (!exitParams) {
		return;
	}

	doPlayerExit(exitParams);
	onReturn(null);
});

function _getExitParams(exitFuncName, parameters) {
	var params = parameters[0].split(',');
	var roomName = params[0];
	var x = params[1];
	var y = params[2];
	var coordsType = (params[3] || 'exit').toLowerCase();
	var useSpriteCoords = coordsType === 'sprite';
	var roomId = getRoom(roomName).id;

	if (!roomName || x === undefined || y === undefined) {
		console.warn('{' + exitFuncName + '} was missing parameters! Usage: {' +
			exitFuncName + ' "roomname,x,y"}');
		return null;
	}

	if (roomId === undefined) {
		console.warn("Bad {" + exitFuncName + "} parameter: Room '" + roomName + "' not found!");
		return null;
	}

	return {
		room: roomId,
		x: Number(x),
		y: useSpriteCoords ? 15 - Number(y) : Number(y)
	};
}

// dest === {room: Room, x: Int, y: Int}
function doPlayerExit(dest) {
	bitsy.player().room = dest.room;
	bitsy.player().x = dest.x;
	bitsy.player().y = dest.y;
	bitsy.curRoom = dest.room;
}
// End of (exit) dialog function mod

}(window));

/**
❄
@file unique items
@summary items which, when picked up, remove all other instances of that item from the game
@license MIT
@version 1.0.0
@author Sean S. LeBlanc

@description
Adds support for items which, when picked up,
remove all other instances of that item from the game.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Update the `itemIsUnique` function to match your needs
*/
(function (bitsy) {
'use strict';
var hackOptions = {
itemIsUnique: function (item) {
  // specific unique item
  //return item.name == 'tea';

  // specific unique item list
  //return ['tea', 'flower', 'hat'].indexOf(item.name) !== -1;

  // unique item flag in name
  return item.name.indexOf('UNIQUE') !== -1;

  // all items are unique
  //return true;
}
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;





var _onInventoryChanged = bitsy.onInventoryChanged;
bitsy.onInventoryChanged = function (id) {
	var r;
	if (_onInventoryChanged) {
		_onInventoryChanged(id);
	}
	if (hackOptions.itemIsUnique(bitsy.item[id])) {
		for (r in bitsy.room) {
			if (bitsy.room.hasOwnProperty(r)) {
				r = bitsy.room[r];
				r.items = r.items.filter(function (i) {
					return i.id != id;
				});
			}
		}
	}
};

}(window));

/**
😌
@file bitsymuse
@summary A variety of Bitsy sound and music handlers
@license MIT
@version 2.2.0
@requires 4.8, 4.9
@author David Mowatt

@description
A hack that adds a variety of audio controls, including music that changes as you move between rooms.
If the same song is played as you move between rooms, the audio file will continue playing.

HOW TO USE:
1. Place your audio files somewhere relative to your bitsy html file (in the zip if you're uploading to itch.io)
2. Copy-paste `<audio id="sound ID" src="relative path to sound file"></audio>` into the <head> of your document.
   You need to do it once for each sound file you are adding, and each needs a unique sound ID. Add `loop` after the `src=""`
   tag if it's music that's going to loop (e.g. `<audio id="sound ID" src="./mySong.mp3" loop></audio>`)
3. Copy-paste this script into a script tag after the bitsy source.
4. Edit hackOptions below to set up the TRACK LIST for rooms you move through.

In addition to the track list, which will play audio based on the room number/name,
you have access to the following commands you can add to dialogue:

1. (soundeffect "<sound ID>") will play a sound without interrupting the music
2. (music "<sound ID>") will change the music as soon as it is called in the dialogue
3. (musicEnd "<sound ID>") will change the music once the dialogue box closes

You can call both music and musicEnd in the same dialogue, to e.g. change the music while you speak to a character
and then restart the regular room music once you stop speaking to them.
You can also use a special ID ("S" by default) to Silence the music.

By default, music tracks automatically restart from the beginning if you go back to a previous track.
This can also be changed in the hackOptions below.
*/
this.hacks = this.hacks || {};
this.hacks.bitsymuse = (function (exports,bitsy) {
'use strict';
var hackOptions = {
// You need to put an entry in this list for every room ID 
// or name that is accessible by the player, and then specify 
// the song ID for each room. Expand this list to as many 
// rooms as you need.

// If the player moves between rooms with the same audio ID 
// the music keeps playing seamlessly. Undefined rooms will 
// keep playing whatever music they were last playing.

// You can set a room to stop music when you enter by using 
// the silenceId instead of a song ID. By default, this is 
// set to 'S'.

// These values are examples, and this hack WILL NOT WORK 
// with these values. Check the Readme for setup instructions.

musicByRoom: {
	'apartment 1': 'main1',
	'brain hub': 'main2',
	'courtroom': 'main1',
	'gallows': 'main1',
	'ambulance': 'phoneCool',
	'cheese factory': 'main1',
	'dark': 'main1',
	'hair pageant1': 'main1',
	'hair pageant2': 'main1',
	'apartment 2': 'main1Reversed',
	'scary hallway': 'scaryQuieter',
	'blood room': 'scary',
	'poop1': 'poopSong',
	'poop2': 'poopSong',
	'wake up': 'main2',
	'gallows2': 'phoneCool',
	'poop3': 'poopSong',
	'poop4': 'poopSong',
	'poop5': 'poopSong',
	'outside': 'main2',
	'title screen': 'main2',
	'intensive': 'poopSong',
	'outside won': 'S',
	'intensive won': 'S',
	'wake up won': 'S',
	'dark2': 'S',
},
silenceId: 'S', // Use this song ID of to make a room fall silent.
resume: true, // If true, songs will pause/resume on change; otherwise, they'll stop/play (doesn't affect sound effects)
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting room by name or id
 * @param {string} name id or name of room to return
 * @return {string} room, or undefined if it doesn't exist
 */
function getRoom(name) {
	var id = bitsy.room.hasOwnProperty(name) ? name : bitsy.names.room.get(name);
	return bitsy.room[id];
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 3.2.2
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	kitsy.queuedInjectScripts.push({
		searchRegex: searchRegex,
		replaceString: replaceString
	});
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var superFn = bitsy[functionName];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	bitsy[functionName] = function () {
		var args = [].slice.call(arguments);
		var i = 0;
		runBefore.apply(this, arguments);

		// Iterate thru sync & async functions. Run each, finally run original.
		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				var newArgs = functions[i++].apply(this, args);
				newArgs = newArgs && newArgs.length ? newArgs : args;
				runBefore.apply(this, newArgs);
			}
		}
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function(match, group){
			if(match.substr(0,1) === '\\') {
				return '('+ group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{'+ group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}


function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		throw new Error('The dialog function "' + tag + '" already exists.');
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (game_data) {
		return [convertDialogTags(game_data, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", function(e, p, o){ kitsy.deferredDialogFunctions.' + tag + '.push({e:e,p:p}); o(null); });'
	);
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}





var currentMusic;
var roomMusicFlag = null;

// expand the map to include ids of rooms listed by name
after('load_game', function () {
	var room;
	for (var i in hackOptions.musicByRoom) {
		if (hackOptions.musicByRoom.hasOwnProperty(i)) {
			room = getRoom(i);
			if (room) {
				hackOptions.musicByRoom[room.id] = hackOptions.musicByRoom[i];
			}
		}
	}
});

var audioCache = {};

function getAudio(id) {
	var el = audioCache[id] || (audioCache[id] = document.getElementById(id));
	if (!el) {
		throw new Error("bitsymuse tried to use audio with id '" + id + "' but couldn't find one on the page!");
	}
	return el;
}

function playSound(soundParam) {
	if (!soundParam) {
		return;
	}
	getAudio(soundParam).play();
}

function changeMusic(newMusic) {
	var audio;
	// if we didn't get new music,
	// or the music didn't change,
	// there's no work to be done
	if (!newMusic || newMusic === currentMusic) {
		return;
	}

	// stop old music
	if (currentMusic && currentMusic !== hackOptions.silenceId) {
		audio = getAudio(currentMusic);
		audio.pause();
		if (!hackOptions.resume) {
			audio.currentTime = 0.0;
		}
	}

	// start new music
	currentMusic = newMusic;
	// special case: don't start anything new
	if (newMusic === hackOptions.silenceId) {
		return;
	}
	getAudio(newMusic).play();
}

after('drawRoom', function () {
	if (roomMusicFlag !== bitsy.curRoom) {
		changeMusic(hackOptions.musicByRoom[bitsy.curRoom]);
		roomMusicFlag = bitsy.curRoom;
	}
});

// Implement the {music} dialog function.
// It changes the music track as soon as it is called.
addDialogTag('music', function (environment, parameters, onReturn) {
	if (!parameters[0]) {
		throw new Error('{music} was missing parameters! Usage: {music "track name"}');
	}
	changeMusic(parameters[0]);
	onReturn(null);
});

// Implement the {musicEnd} dialog function.
// It changes the music track once the dialog closes.
addDeferredDialogTag('musicEnd', function (environment, parameters) {
	if (!parameters[0]) {
		throw new Error('{musicEnd} was missing parameters! Usage: {musicEnd "track name"}');
	}
	changeMusic(parameters[0]);
});

addDialogTag('soundeffect', function (environment, parameters, onReturn) {
	if (!parameters[0]) {
		throw new Error('{soundeffect} was missing parameters! Usage: {soundeffect "track name"}');
	}
	playSound(parameters[0]);
	onReturn(null);
});
// End of (music) dialog function mod

exports.hackOptions = hackOptions;

return exports;

}({},window));



</script>

<script type="text/javascript" id="borksyAdditionalJS">
/**
👥
@file avatar by room
@summary change the avatar in certain rooms
@license MIT
@version 1.0
@requires 5.3
@author Sean S. LeBlanc
@description
Simple hack for changing avatar to another sprite as you move between rooms.
HOW TO USE:
1. Copy-paste into a script tag after the bitsy source
2. Edit hackOptions below to set up the avatar list for rooms you move through.
By default, the avatar will reset to the default if you enter a room without a sprite defined.
This can also be changed in the hackOptions below to instead apply avatar changes permanently.
*/
(function (bitsy) {
'use strict';
var hackOptions = {
	permanent: true, // If true, avatar changes will persist across rooms without sprites defined
	// You need to put an entry in this list for every room ID or name that you want to change the avatar,
	// and then specify the sprite ID or name of what to change to. Expand this list to as many rooms as you need.
	avatarByRoom: {
		// note that 'A' is the player sprite, so this does nothing by default, but will reset the player if permanent == true
		'gallows': 'player cow2',
		'brain hub': 'A',
		'wake up': 'player cowboy',
		'title screen': 'A',
		'outside': 'player cowboy',
		'intensive won': 'player cowboy',
		'intensive': 'tryAgain'
	},
};

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/*
Helper for getting image by name or id
Args:
	name: id or name of image to return
	 map: map of images (e.g. `sprite`, `tile`, `item`)
Returns: the image in the given map with the given name/id
 */
function getImage(name, map) {
	var id = map.hasOwnProperty(name) ? name : Object.keys(map).find(function (e) {
		return map[e].name == name;
	});
	return map[id];
}

/**
 * Helper for getting room by name or id
 * @param {string} name id or name of room to return
 * @return {string} room, or undefined if it doesn't exist
 */
function getRoom(name) {
	var id = bitsy.room.hasOwnProperty(name) ? name : bitsy.names.room.get(name);
	return bitsy.room[id];
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**
@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 3.2.2
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo
@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";
  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);
  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var superFn = bitsy[functionName];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	bitsy[functionName] = function () {
		var args = [].slice.call(arguments);
		var i = 0;
		runBefore.apply(this, arguments);

		// Iterate thru sync & async functions. Run each, finally run original.
		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				var newArgs = functions[i++].apply(this, args);
				newArgs = newArgs && newArgs.length ? newArgs : args;
				runBefore.apply(this, newArgs);
			}
		}
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}





// expand the map to include ids of rooms listed by name
// and store the original player sprite
var originalAvatar;
after('load_game', function () {
	var room;
	for (var i in hackOptions.avatarByRoom) {
		if (hackOptions.avatarByRoom.hasOwnProperty(i)) {
			room = getRoom(i);
			if (room) {
				hackOptions.avatarByRoom[room.id] = hackOptions.avatarByRoom[i];
			}
		}
	}
	originalAvatar = bitsy.player().drw;
});

var currentRoom;
before('update', function () {
	if (bitsy.curRoom !== currentRoom) {
		currentRoom = bitsy.curRoom;
		var newAvatarId = hackOptions.avatarByRoom[currentRoom];
		if (
			(!newAvatarId && !hackOptions.permanent) // if no sprite defined + not permanent, reset
			||
			(newAvatarId === bitsy.playerId) // manual reset
		) {
			bitsy.player().drw = originalAvatar;
			return;
		}
		if (newAvatarId === bitsy.playerId) {
			bitsy.player().drw;
		}
		var newAvatar = getImage(newAvatarId, bitsy.sprite);
		if (!newAvatar) {
			throw new Error('Could not find sprite "' + newAvatarId + '" for room "' + currentRoom + '"');
		}
		bitsy.player().drw = newAvatar.drw;
	}
});

}(window));

/**
🔚
@file end-from-dialog
@summary trigger an ending from dialog, including narration text
@license WTFPL (do WTF you want)
@version 3.2.1
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
Lets you end the game from dialog (including inside conditionals).

Using the (end) function in any part of a series of dialog will make the
game end after the dialog is finished. Ending the game resets it back to the
intro.

Using (endNow) at the end of a sentence will display the whole sentence and
immediately clear the background. No further dialog from that passage will
display, and the game will reset when you proceed. Using (endNow) with
narration text will immediately exit the dialog, clear the background, and
show the ending narration in an ending-style centered dialog box.

Usage: (end)
       (end "<ending narration>")
       (endNow)
       (endNow "<ending narration>")

Example: (end)
         (end "Five friars bid you goodbye. You leave the temple, hopeful.")
         (endNow "The computer is still online! The chamber floods with neurotoxin.")

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/
this.hacks = this.hacks || {};
(function (bitsy) {
'use strict';

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 3.3.0
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/


// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
function inject$1(searchRegex, replaceString) {
	var kitsy = kitsyInit();
	kitsy.queuedInjectScripts.push({
		searchRegex: searchRegex,
		replaceString: replaceString
	});
}

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var superFn = bitsy[functionName];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	bitsy[functionName] = function () {
		var args = [].slice.call(arguments);
		var i = 0;
		runBefore.apply(this, arguments);

		// Iterate thru sync & async functions. Run each, finally run original.
		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				var newArgs = functions[i++].apply(this, args);
				newArgs = newArgs && newArgs.length ? newArgs : args;
				runBefore.apply(this, newArgs);
			}
		}
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input
		.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".+?"|.+?))?)\\\\?\\)', 'g'), function(match, group){
			if(match.substr(0,1) === '\\') {
				return '('+ group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
			}
			return '{'+ group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
		});
}


function addDialogFunction(tag, fn) {
	var kitsy = kitsyInit();
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		throw new Error('The dialog function "' + tag + '" already exists.');
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (game_data) {
		return [convertDialogTags(game_data, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", kitsy.dialogFunctions.' + tag + ');'
	);
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 * 
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = bitsy.kitsy.deferredDialogFunctions[tag] = [];
	inject$1(
		/(var functionMap = new Map\(\);)/,
		'$1functionMap.set("' + tag + '", function(e, p, o){ kitsy.deferredDialogFunctions.' + tag + '.push({e:e,p:p}); o(null); });'
	);
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function(environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}



// Implement the dialog functions
addDualDialogTag('end', function (environment, parameters) {
  bitsy.dialogBuffer.EndDialog();
	bitsy.startNarrating(parameters[0] || null, true);
});
// End of (end) dialog function mod

}(window));

/**
🎮
@file gamepad input
@summary HTML5 gamepad support
@license MIT
@version 2.1.0
@requires Bitsy Version: 5.1
@author Sean S. LeBlanc

@description
Adds support for gamepad input.

Directional input is mapped to the left and right analog sticks, the dpad, and the face buttons (e.g. ABXY).
The same hold-to-move logic used for keyboard input is shared with the gamepad input.

HOW TO USE:
Copy-paste this script into a script tag after the bitsy source
*/
this.hacks = this.hacks || {};
(function (bitsy) {
'use strict';

bitsy = bitsy && bitsy.hasOwnProperty('default') ? bitsy['default'] : bitsy;

var gamepads = {
	// XBOX360 wired controller configuration
	// buttons
	A: 0,
	X: 2,
	B: 1,
	Y: 3,
	LB: 4,
	RB: 5,
	LT: 6,
	RT: 7,
	BACK: 8,
	START: 9,
	LHAT: 10,
	RHAT: 11,
	DPAD_UP: 12,
	DPAD_DOWN: 13,
	DPAD_LEFT: 14,
	DPAD_RIGHT: 15,

	// axes
	LSTICK_H: 0,
	LSTICK_V: 1,
	RSTICK_H: 2,
	RSTICK_V: 3,


	players: [],

	available: false,
	pollEveryFrame: false,
	connected: false,
	deadZone: 0.25, // if abs(an axis value) is < deadZone, returns 0 instead
	snapZone: 0.25, // if abs(1-an axis value) is < snapZone, returns 1 instead

	init: function () {
		if (navigator.getGamepads) {
			this.available = true;
		} else if (navigator.webkitGetGamepads) {
			navigator.getGamepads = navigator.webkitGetGamepads;
			this.available = true;
		}

		if (this.available) {
			console.log("Gamepad API available");
			if (navigator.userAgent.indexOf('Firefox/') != -1) {
				// listen to connection events for firefox
				window.addEventListener("gamepadconnected", function (event) {
					console.log("gamepad connection event");
					this.pollconnections(event);
				}.bind(this));
				window.addEventListener("gamepaddisconnected", function (event) {
					console.log("gamepad connection event");
					this.pollconnections(event);
				}.bind(this));
			} else {
				this.pollEveryFrame = true;
			}
		} else {
			console.error("Gamepad API not available");
		}
	},

	pollconnections: function (event) {
		this.connected = false;

		// assume existing players' gamepads aren't enabled until they're found
		for (var i = 0; i < this.players.length; ++i) {
			if (this.players[i]) {
				this.players[i].disabled = true;
			}
		}

		var gps = navigator.getGamepads();
		for (var i = 0; i < gps.length; ++i) {
			var gp = gps[i];
			if (gp) {
				if (gp.connected) {
					if (this.players[gp.index] == null) {
						// new player
						gp.down = [];
						gp.justDown = [];
						gp.justUp = [];
						gp.axesPrev = [];
						this.players[gp.index] = gp;
					} else {
						// returning player, copy old button states before replacing
						gp.down = this.players[gp.index].down;
						gp.justDown = this.players[gp.index].justDown;
						gp.justUp = this.players[gp.index].justUp;
						gp.axesPrev = this.players[gp.index].axesPrev;
						this.players[gp.index] = gp;
					}
					this.connected = true;
					this.players[gp.index].disabled = false;
				} else {
					this.players[gp.index] = null;
				}
			}
		}
	},

	update: function () {
		// store the previous axis values
		// has to be done before pollConnections since that will get the new axis values
		for (var i = 0; i < this.players.length; ++i) {
			var p = this.getPlayer(i);
			p.axesPrev = p.axes.slice();
		}

		// poll connections and update gamepad states every frame because chrome's a lazy bum
		if (this.pollEveryFrame) {
			this.pollconnections();
		}

		for (var i = 0; i < this.players.length; ++i) {
			var p = this.getPlayer(i);
			if (p && p != null) {
				for (var j = 0; j < p.buttons.length; ++j) {
					if (p.buttons[j].pressed) {
						p.justDown[j] = !(p.down[j] === true);
						p.down[j] = true;
						p.justUp[j] = false;
					} else {
						p.justUp[j] = p.down[j] === true;
						p.down[j] = false;
						p.justDown[j] = false;
					}
				}
			}

		}
	},

	// returns _player's gamepad
	// if one doesn't exist, returns an object with gamepad properties reflecting a null state
	getPlayer: function (_player) {
		if (this.players[_player] && this.players[_player].connected && !this.players[_player].disabled) {
			return this.players[_player];
		} else {
			return {
				connected: false,
				disabled: true,
				down: [],
				justDown: [],
				justUp: [],
				axes: [],
				axesPrev: [],
				buttons: []
			};
		}
	},

	// returns an array representing _length axes for _player at _offset
	// if abs(an axis value) is < deadZone, returns 0 instead
	// if abs(1-an axis value) is < snapZone, returns 1/-1 instead
	// otherwise, returns the axis value, normalized between deadZone and (1-snapZone)
	// if _offset isn't set, sets to 0
	// if _length isn't set, sets to 2
	// if _player isn't set (or -1), returns the sum of everyone's axes
	// if _prev is set and true, uses the axis values from the previous frame instead of the current one
	getAxes: function (_offset, _length, _player, _prev) {
		if (arguments.length < 4) {
			_prev = false;
			if (arguments.length < 3) {
				_player = -1;
				if (arguments.length < 2) {
					_length = 2;
					if (arguments.length < 1) {
						_offset = 0;
					}
				}
			}
		}

		var axes = [];
		for (var i = 0; i < _length; ++i) {
			axes[i] = 0;
		}
		if (_player == -1) {
			for (var i = 0; i < this.players.length; ++i) {
				var a = this.getAxes(_offset, _length, i, _prev);
				for (var j = 0; j < a.length; ++j) {
					axes[j] += a[j];
				}
			}
		} else {
			var p = this.getPlayer(_player);
			var a = _prev ? p.axesPrev : p.axes;
			a = a.slice(_offset, _offset + _length);
			for (var i = 0; i < a.length; ++i) {
				if (Math.abs(a[i]) < this.deadZone) {
					axes[i] += 0;
				} else if (Math.abs(1.0 - a[i]) < this.snapZone) {
					axes[i] += 1;
				} else if (Math.abs(-1.0 - a[i]) < this.snapZone) {
					axes[i] -= 1;
				} else {
					axes[i] += Math.sign(a[i]) * (Math.abs(a[i]) - this.deadZone) / (1.0 - this.snapZone - this.deadZone);
				}
			}
		}
		return axes;
	},
	// returns getAxes(_axis,1,_player)[0]
	// if _player isn't set, returns the sum of everyone's axis
	// if _prev is set and true, uses the axis values from the previous frame instead of the current one
	getAxis: function (_axis, _player, _prev) {
		if (arguments.length < 3) {
			_prev = false;
			if (arguments.length < 2) {
				_player = -1;
			}
		}
		return this.getAxes(_axis, 1, _player, _prev)[0];
	},

	// returns true if _axis is past _threshold in _direction
	// if _direction isn't set, assumes the sign of _theshold is the direction (e.g. if the theshold is -0.5, it will check if _axis is < -0.5)
	// if _player isn't set, returns true for any player
	// if _prev is set and true, uses the axis values from the previous frame instead of the current one
	axisPast: function (_axis, _threshold, _direction, _player, _prev) {
		if (arguments.length < 5) {
			_prev = false;
			if (arguments.length < 4) {
				_player = -1;
				if (arguments.length < 3) {
					_direction = Math.sign(_threshold);
					if (arguments.length < 2) {
						console.error("must specify axis and threshold");
					}
				}
			}
		}

		var a = this.getAxis(_axis, _player, _prev);



		if (_direction < 0) {
			return a < _threshold;
		} else if (_direction > 0) {
			return a > _threshold;
		} else {
			console.error("direction can't be zero");
		}
	},
	// returns true if _axis is past _threshold in _direction and WAS NOT in previous update
	// if _direction isn't set, assumes the sign of _theshold is the direction (e.g. if the theshold is -0.5, it will check if _axis is < -0.5)
	// if _player isn't set, returns true for any player
	axisJustPast: function (_axis, _threshold, _direction, _player) {
		if (arguments.length < 4) {
			_player = -1;
			if (arguments.length < 3) {
				_direction = Math.sign(_threshold);
				if (arguments.length < 2) {
					console.error("must specify axis and threshold");
				}
			}
		}
		return this.axisPast(_axis, _threshold, _direction, _player, false) && !this.axisPast(_axis, _threshold, _direction, _player, true);
	},

	// returns [x,y] representing the dpad for _player
	// if _player isn't set (or -1), returns the sum of everyone's dpads
	getDpad: function (_player) {
		if (arguments.length < 1) {
			_player = -1;
		}
		var dpad = [0, 0];
		if (_player == -1) {
			for (var i = 0; i < this.players.length; ++i) {
				var d = this.getDpad(i);
				dpad[0] += d[0];
				dpad[1] += d[1];
			}
		} else {
			if (this.isDown(this.DPAD_RIGHT, _player)) {
				dpad[0] += 1;
			}
			if (this.isDown(this.DPAD_LEFT, _player)) {
				dpad[0] -= 1;
			}
			if (this.isDown(this.DPAD_UP, _player)) {
				dpad[1] += 1;
			}
			if (this.isDown(this.DPAD_DOWN, _player)) {
				dpad[1] -= 1;
			}
		}
		return dpad;
	},

	// returns true if _player's _btn is currently down
	// if _player isn't set (or -1), returns true for any player
	isDown: function (_btn, _player) {
		if (arguments.length < 2) {
			_player = -1;
			if (arguments.length < 1) {
				console.error("must specify a button");
			}
		}
		if (_player == -1) {
			for (var i = 0; i < this.players.length; ++i) {
				if (this.isDown(_btn, i)) {
					return true;
				}
			}
			return false;
		} else {
			return this.getPlayer(_player).down[_btn] === true;
		}
	},

	// returns true if _player's _btn is not currently down
	// if _player isn't set (or -1), returns true for any player
	isUp: function (_btn, _player) {
		return !this.isDown(_btn, _player);
	},

	// returns true if _player's _btn is currently down and WAS NOT down in previous update
	// if _player isn't set (or -1), returns true for any player
	isJustDown: function (_btn, _player) {
		if (arguments.length < 2) {
			_player = -1;
			if (arguments.length < 1) {
				console.error("must specify a button");
			}
		}
		if (_player == -1) {
			for (var i = 0; i < this.players.length; ++i) {
				if (this.isJustDown(_btn, i)) {
					return true;
				}
			}
			return false;
		} else {
			return this.getPlayer(_player).justDown[_btn] === true;
		}
	},

	// returns true if _player's _btn is currently NOT down and WAS down in previous update
	// if _player isn't set (or -1), returns true for any player
	isJustUp: function (_btn, _player) {
		if (arguments.length < 2) {
			_player = -1;
			if (arguments.length < 1) {
				console.error("must specify a button");
			}
		}
		if (_player == -1) {
			for (var i = 0; i < this.players.length; ++i) {
				if (this.isJustUp(_btn, i)) {
					return true;
				}
			}
			return false;
		} else {
			return this.getPlayer(_player).justUp[_btn] === true
		}	}
};

var inputGamepads = gamepads;

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw 'Couldn\'t find "' + searchRegex + '" in script tags';
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/**
 * Helper for getting an array with unique elements 
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
	return array.filter(function (item, idx) {
		return array.indexOf(item) === idx;
	});
}

/**

@file kitsy-script-toolkit
@summary makes it easier and cleaner to run code before and after Bitsy functions or to inject new code into Bitsy script tags
@license WTFPL (do WTF you want)
@version 3.3.0
@requires Bitsy Version: 4.5, 4.6
@author @mildmojo

@description
HOW TO USE:
  import {before, after, inject, addDialogTag, addDeferredDialogTag} from "./helpers/kitsy-script-toolkit";

  before(targetFuncName, beforeFn);
  after(targetFuncName, afterFn);
  inject(searchRegex, replaceString);
  addDialogTag(tagName, dialogFn);
  addDeferredDialogTag(tagName, dialogFn);

  For more info, see the documentation at:
  https://github.com/seleb/bitsy-hacks/wiki/Coding-with-kitsy
*/

// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
	var kitsy = kitsyInit();
	kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
	kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}

// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
	var kitsy = kitsyInit();
	kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
	kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}

function kitsyInit() {
	// return already-initialized kitsy
	if (bitsy.kitsy) {
		return bitsy.kitsy;
	}

	// Initialize kitsy
	bitsy.kitsy = {
		queuedInjectScripts: [],
		queuedBeforeScripts: {},
		queuedAfterScripts: {}
	};

	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts and hook everything up.
		doInjects();
		applyAllHooks();

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};

	return bitsy.kitsy;
}


function doInjects() {
	bitsy.kitsy.queuedInjectScripts.forEach(function (injectScript) {
		inject(injectScript.searchRegex, injectScript.replaceString);
	});
	_reinitEngine();
}

function applyAllHooks() {
	var allHooks = unique(Object.keys(bitsy.kitsy.queuedBeforeScripts).concat(Object.keys(bitsy.kitsy.queuedAfterScripts)));
	allHooks.forEach(applyHook);
}

function applyHook(functionName) {
	var superFn = bitsy[functionName];
	var superFnLength = superFn ? superFn.length : 0;
	var functions = [];
	// start with befores
	functions = functions.concat(bitsy.kitsy.queuedBeforeScripts[functionName] || []);
	// then original
	if (superFn) {
		functions.push(superFn);
	}
	// then afters
	functions = functions.concat(bitsy.kitsy.queuedAfterScripts[functionName] || []);

	// overwrite original with one which will call each in order
	bitsy[functionName] = function () {
		var args = [].slice.call(arguments);
		var i = 0;
		runBefore.apply(this, arguments);

		// Iterate thru sync & async functions. Run each, finally run original.
		function runBefore() {
			// All outta functions? Finish
			if (i === functions.length) {
				return;
			}

			// Update args if provided.
			if (arguments.length > 0) {
				args = [].slice.call(arguments);
			}

			if (functions[i].length > superFnLength) {
				// Assume funcs that accept more args than the original are
				// async and accept a callback as an additional argument.
				functions[i++].apply(this, args.concat(runBefore.bind(this)));
			} else {
				// run synchronously
				var newArgs = functions[i++].apply(this, args);
				newArgs = newArgs && newArgs.length ? newArgs : args;
				runBefore.apply(this, newArgs);
			}
		}
	};
}

function _reinitEngine() {
	// recreate the script and dialog objects so that they'll be
	// referencing the code with injections instead of the original
	bitsy.scriptModule = new bitsy.Script();
	bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

	bitsy.dialogModule = new bitsy.Dialog();
	bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
	bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
}



before('startExportedGame', inputGamepads.init.bind(inputGamepads));
var empty = function () {};

var move = function (dpad, face, axis, axis2, axispast, axisdir, key) {
	// keydown
	if (
		inputGamepads.isJustDown(dpad) ||
		inputGamepads.isJustDown(face) ||
		inputGamepads.axisJustPast(axis, axispast, axisdir) ||
		(
			bitsy.playerHoldToMoveTimer <= 0 && (
				inputGamepads.isDown(dpad) ||
				inputGamepads.isDown(face) ||
				inputGamepads.axisPast(axis, axispast, axisdir)
			)
		)
	) {
		bitsy.curPlayerDirection = bitsy.Direction.None;
		bitsy.input.onkeydown({
			keyCode: key,
			preventDefault: empty
		});
	}

	// keyup
	if (
		inputGamepads.isJustUp(dpad) ||
		inputGamepads.isJustUp(face) ||
		inputGamepads.axisJustPast(axis, axispast, -axisdir)
	) {
		bitsy.input.onkeyup({
			keyCode: key,
			preventDefault: empty
		});
	}
};

before('update', function(){
	move(inputGamepads.DPAD_LEFT, inputGamepads.X, inputGamepads.LSTICK_H, inputGamepads.RSTICK_H, -0.5, -1, bitsy.key.left);
	move(inputGamepads.DPAD_RIGHT, inputGamepads.B, inputGamepads.LSTICK_H, inputGamepads.RSTICK_H, 0.5, 1, bitsy.key.right);
	move(inputGamepads.DPAD_UP, inputGamepads.Y, inputGamepads.LSTICK_V, inputGamepads.RSTICK_V, -0.5, -1, bitsy.key.up);
	move(inputGamepads.DPAD_DOWN, inputGamepads.A, inputGamepads.LSTICK_V, inputGamepads.RSTICK_V, 0.5, 1, bitsy.key.down);
});
after('update', function(){
	inputGamepads.update();
});

}(window));

</script>

</head>

<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
<audio preload="auto" id="cutTheRope1" src="sound/cutTheRope1.mp3"></audio>
<audio preload="auto" id="cutTheRope2" src="sound/cutTheRope2.mp3"></audio>
<audio preload="auto" id="main1" src="sound/main1.mp3" loop></audio>
<audio preload="auto" id="main2" src="sound/main2.mp3" loop></audio>
<audio preload="auto" id="won" src="sound/won.mp3"></audio>
<audio preload="auto" id="memento1" src="sound/memento.mp3"></audio>
<audio preload="auto" id="memento2" src="sound/memento.mp3"></audio>
<audio preload="auto" id="memento3" src="sound/memento.mp3"></audio>
<audio preload="auto" id="memento4" src="sound/mementoDistort.mp3"></audio>
<audio preload="auto" id="memento5" src="sound/memento.mp3"></audio>
<audio preload="auto" id="newPageant" src="sound/newPageant.mp3"></audio>
<audio preload="auto" id="nurseScare" src="sound/nurseScare.mp3"></audio>
<audio preload="auto" id="poopSong" src="sound/poopSong.mp3" loop></audio>
<audio preload="auto" id="pwet" src="sound/pwet.mp3"></audio>
<audio preload="auto" id="monitor" src="sound/monitor.mp3"></audio>
<audio preload="auto" id="scaryQuieter" src="sound/scaryQuieter.mp3" loop></audio>
<audio preload="auto" id="scary" src="sound/scary.mp3" loop></audio>
<audio preload="auto" id="phoneDino" src="sound/phoneDino.mp3" loop></audio>
<audio preload="auto" id="phoneCool" src="sound/phoneCool.mp3" loop></audio>
<audio preload="auto" id="main1Reversed" src="sound/main1Reversed.mp3" loop></audio>
<!-- GAME CANVAS -->
<canvas id='game'></canvas>
</body>

</html>